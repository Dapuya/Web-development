{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst webdriver_commands_1 = require(\"./webdriver_commands\");\n\nconst HIGHLIGHT_COMMAND = [webdriver_commands_1.CommandName.ElementClick, webdriver_commands_1.CommandName.ElementSendKeys, webdriver_commands_1.CommandName.ElementClear];\n\nlet clientScripts = require('./client_scripts/highlight.js');\n/**\n * A barrier that delays forwarding WebDriver commands that can affect the app (ie, clicks or\n * sending text) for a fixed amount of time. During the delay, the element that's the target\n * of the command will be highlighted by drawing a transparent div on top of it.\n */\n\n\nclass HighlightDelayBarrier {\n  constructor(client, delay) {\n    this.client = client;\n    this.delay = delay;\n  }\n\n  isHighlightCommand(command) {\n    return HIGHLIGHT_COMMAND.indexOf(command.commandName) !== -1;\n  }\n\n  highlightData(top, left, width, height) {\n    return JSON.stringify({\n      script: 'return (' + clientScripts.HIGHLIGHT_FN + ').apply(null, arguments);',\n      args: [top, left, width, height]\n    });\n  }\n\n  removeHighlightData() {\n    return JSON.stringify({\n      script: 'return (' + clientScripts.REMOVE_HIGHLIGHT_FN + ').apply(null, arguments);',\n      args: []\n    });\n  } // Simple promise-based sleep so we can use async/await\n\n\n  sleep(delay) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve();\n      }, delay);\n    });\n  }\n\n  onCommand(command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isHighlightCommand(command) || !this.delay) {\n        return;\n      }\n\n      const sessId = command.sessionId;\n      const el = command.getParam('elementId'); // The W3C spec does have a 'getRect', but the standalone server doesn't support it yet.\n\n      const loc = yield this.client.getLocation(sessId, el);\n      const size = yield this.client.getSize(sessId, el); // Set the highlight\n\n      yield this.client.execute(sessId, this.highlightData(loc['y'], loc['x'], size['width'], size['height'])); // Wait\n\n      yield this.sleep(this.delay); // Clear the highlight\n\n      yield this.client.execute(sessId, this.removeHighlightData());\n    });\n  }\n\n}\n\nexports.HighlightDelayBarrier = HighlightDelayBarrier;","map":{"version":3,"sources":["/Users/dariya/Documents/GitHub/Web-development/lab 4&5/wgg87w--run/node_modules/blocking-proxy/built/lib/highlight_delay_barrier.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","webdriver_commands_1","require","HIGHLIGHT_COMMAND","CommandName","ElementClick","ElementSendKeys","ElementClear","clientScripts","HighlightDelayBarrier","constructor","client","delay","isHighlightCommand","command","indexOf","commandName","highlightData","top","left","width","height","JSON","stringify","script","HIGHLIGHT_FN","args","removeHighlightData","REMOVE_HIGHLIGHT_FN","sleep","setTimeout","onCommand","sessId","sessionId","el","getParam","loc","getLocation","size","getSize","execute"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webdriver_commands_1 = require(\"./webdriver_commands\");\nconst HIGHLIGHT_COMMAND = [webdriver_commands_1.CommandName.ElementClick, webdriver_commands_1.CommandName.ElementSendKeys, webdriver_commands_1.CommandName.ElementClear];\nlet clientScripts = require('./client_scripts/highlight.js');\n/**\n * A barrier that delays forwarding WebDriver commands that can affect the app (ie, clicks or\n * sending text) for a fixed amount of time. During the delay, the element that's the target\n * of the command will be highlighted by drawing a transparent div on top of it.\n */\nclass HighlightDelayBarrier {\n    constructor(client, delay) {\n        this.client = client;\n        this.delay = delay;\n    }\n    isHighlightCommand(command) {\n        return HIGHLIGHT_COMMAND.indexOf(command.commandName) !== -1;\n    }\n    highlightData(top, left, width, height) {\n        return JSON.stringify({\n            script: 'return (' + clientScripts.HIGHLIGHT_FN + ').apply(null, arguments);',\n            args: [top, left, width, height]\n        });\n    }\n    removeHighlightData() {\n        return JSON.stringify({\n            script: 'return (' + clientScripts.REMOVE_HIGHLIGHT_FN + ').apply(null, arguments);',\n            args: []\n        });\n    }\n    // Simple promise-based sleep so we can use async/await\n    sleep(delay) {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, delay);\n        });\n    }\n    onCommand(command) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isHighlightCommand(command) || !this.delay) {\n                return;\n            }\n            const sessId = command.sessionId;\n            const el = command.getParam('elementId');\n            // The W3C spec does have a 'getRect', but the standalone server doesn't support it yet.\n            const loc = yield this.client.getLocation(sessId, el);\n            const size = yield this.client.getSize(sessId, el);\n            // Set the highlight\n            yield this.client.execute(sessId, this.highlightData(loc['y'], loc['x'], size['width'], size['height']));\n            // Wait\n            yield this.sleep(this.delay);\n            // Clear the highlight\n            yield this.client.execute(sessId, this.removeHighlightData());\n        });\n    }\n}\nexports.HighlightDelayBarrier = HighlightDelayBarrier;\n"]},"metadata":{},"sourceType":"script"}