{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, Key, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver', Key.RETURN);\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver', Key.RETURN);\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver', Key.RETURN);\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n'use strict';\n\nconst error = require('./error');\n\nconst events = require('./events');\n\nconst logging = require('./logging');\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\n\n\nconst NativePromise = Promise;\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\n\nvar LONG_STACK_TRACES = false; // TODO: this should not be CONSTANT_CASE\n\n/** @const */\n\nconst LOG = logging.getLogger('promise');\nconst UNIQUE_IDS = new WeakMap();\nlet nextId = 1;\n\nfunction getUid(obj) {\n  let id = UNIQUE_IDS.get(obj);\n\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n\n  return id;\n}\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\n\n\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function () {\n    try {\n      fn();\n    } catch (ignored) {// Do nothing.\n    }\n  });\n}\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\n\n\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\n\n\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n\n  return e;\n}\n/**\n * Error used when the computation of a promise is cancelled.\n */\n\n\nclass CancellationError extends Error {\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  constructor(opt_msg) {\n    super(opt_msg);\n    /** @override */\n\n    this.name = this.constructor.name;\n    /** @private {boolean} */\n\n    this.silent_ = false;\n  }\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n\n\n  static wrap(error, opt_msg) {\n    var message;\n\n    if (error instanceof CancellationError) {\n      return new CancellationError(opt_msg ? opt_msg + ': ' + error.message : error.message);\n    } else if (opt_msg) {\n      message = opt_msg;\n\n      if (error) {\n        message += ': ' + error;\n      }\n\n      return new CancellationError(message);\n    }\n\n    if (error) {\n      message = error + '';\n    }\n\n    return new CancellationError(message);\n  }\n\n}\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\n\n\nclass FlowResetError extends CancellationError {\n  constructor() {\n    super('ControlFlow was reset');\n    this.silent_ = true;\n  }\n\n}\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\n\n\nclass DiscardedTaskError extends CancellationError {\n  /** @param {*} error The original error. */\n  constructor(error) {\n    if (error instanceof DiscardedTaskError) {\n      return (\n        /** @type {!DiscardedTaskError} */\n        error\n      );\n    }\n\n    var msg = '';\n\n    if (error) {\n      msg = ': ' + (typeof error.message === 'string' ? error.message : error);\n    }\n\n    super('Task was discarded due to a previous failure' + msg);\n    this.silent_ = true;\n  }\n\n}\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\n\n\nclass MultipleUnhandledRejectionError extends Error {\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  constructor(errors) {\n    super('Multiple unhandled promise rejections reported');\n    /** @override */\n\n    this.name = this.constructor.name;\n    /** @type {!Set<*>} */\n\n    this.errors = errors;\n  }\n\n}\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\n\n\nconst IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nconst CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\n\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {// Property access denied?\n  }\n}\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\n\n\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false; // Property access seems to be forbidden.\n  }\n}\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\n\n\nclass Thenable {\n  /**\n   * Adds a property to a class prototype to allow runtime checks of whether\n   * instances of that class implement the Thenable interface.\n   * @param {function(new: Thenable, ...?)} ctor The\n   *     constructor whose prototype to modify.\n   */\n  static addImplementation(ctor) {\n    addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n  }\n  /**\n   * Checks if an object has been tagged for implementing the Thenable\n   * interface as defined by {@link Thenable.addImplementation}.\n   * @param {*} object The object to test.\n   * @return {boolean} Whether the object is an implementation of the Thenable\n   *     interface.\n   */\n\n\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n  }\n  /**\n   * Registers listeners for when this instance is resolved.\n   *\n   * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n   *     function to call if this promise is successfully resolved. The function\n   *     should expect a single argument: the promise's resolved value.\n   * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n   *     The function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n\n\n  then(opt_callback, opt_errback) {}\n  /**\n   * Registers a listener for when this promise is rejected. This is synonymous\n   * with the {@code catch} clause in a synchronous API:\n   *\n   *     // Synchronous API:\n   *     try {\n   *       doSynchronousWork();\n   *     } catch (ex) {\n   *       console.error(ex);\n   *     }\n   *\n   *     // Asynchronous promise API:\n   *     doAsynchronousWork().catch(function(ex) {\n   *       console.error(ex);\n   *     });\n   *\n   * @param {function(*): (R|IThenable<R>)} errback The\n   *     function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n\n\n  catch(errback) {}\n\n}\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\n\n\nclass CancellableThenable {\n  /**\n   * @param {function(new: CancellableThenable, ...?)} ctor\n   */\n  static addImplementation(ctor) {\n    Thenable.addImplementation(ctor);\n    addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n  }\n  /**\n   * @param {*} object\n   * @return {boolean}\n   */\n\n\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n  }\n  /**\n   * Requests the cancellation of the computation of this promise's value,\n   * rejecting the promise in the process. This method is a no-op if the promise\n   * has already been resolved.\n   *\n   * @param {(string|Error)=} opt_reason The reason this promise is being\n   *     cancelled. This value will be wrapped in a {@link CancellationError}.\n   */\n\n\n  cancel(opt_reason) {}\n\n}\n/**\n * @enum {string}\n */\n\n\nconst PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\n\nconst ON_CANCEL_HANDLER = new WeakMap();\nconst SKIP_LOG = Symbol('skip-log');\nconst FLOW_LOG = logging.getLogger('promise.ControlFlow');\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\n\nclass ManagedPromise {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(resolver, opt_flow, opt_skipLog) {\n    if (!usePromiseManager()) {\n      throw TypeError('Unable to create a managed promise instance: the promise manager has' + ' been disabled by the SELENIUM_PROMISE_MANAGER environment' + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(() => {\n        let e = captureStackTrace('ManagedPromiseError', 'Creating a new managed Promise. This call will fail when the' + ' promise manager is disabled', ManagedPromise);\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n    /** @private {!ControlFlow} */\n\n    this.flow_ = opt_flow || controlFlow();\n    /** @private {Error} */\n\n    this.stack_ = null;\n\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n    /** @private {Thenable<?>} */\n\n\n    this.parent_ = null;\n    /** @private {Array<!Task>} */\n\n    this.callbacks_ = null;\n    /** @private {PromiseState} */\n\n    this.state_ = PromiseState.PENDING;\n    /** @private {boolean} */\n\n    this.handled_ = false;\n    /** @private {*} */\n\n    this.value_ = undefined;\n    /** @private {TaskQueue} */\n\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function (value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function (reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n\n\n  static resolve(opt_value) {\n    if (opt_value instanceof ManagedPromise) {\n      return opt_value;\n    }\n\n    return new ManagedPromise(resolve => resolve(opt_value));\n  }\n  /**\n   * Creates a promise that is immediately rejected with the given reason.\n   *\n   * @param {*=} opt_reason The rejection reason.\n   * @return {!ManagedPromise<?>} A new rejected promise.\n   */\n\n\n  static reject(opt_reason) {\n    return new ManagedPromise((_, reject) => reject(opt_reason));\n  }\n  /** @override */\n\n\n  toString() {\n    return 'ManagedPromise::' + getUid(this) + ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n  }\n  /**\n   * Resolves this promise. If the new value is itself a promise, this function\n   * will wait for it to be resolved before notifying the registered listeners.\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @throws {TypeError} If {@code newValue === this}.\n   * @private\n   */\n\n\n  resolve_(newState, newValue) {\n    if (PromiseState.PENDING !== this.state_) {\n      return;\n    }\n\n    if (newValue === this) {\n      // See promise a+, 2.3.1\n      // http://promises-aplus.github.io/promises-spec/#point-48\n      newValue = new TypeError('A promise may not resolve to itself');\n      newState = PromiseState.REJECTED;\n    }\n\n    this.parent_ = null;\n    this.state_ = PromiseState.BLOCKED;\n\n    if (newState !== PromiseState.REJECTED) {\n      if (Thenable.isImplementation(newValue)) {\n        // 2.3.2\n        newValue =\n        /** @type {!Thenable} */\n        newValue;\n        this.parent_ = newValue;\n        newValue.then(this.unblockAndResolve_.bind(this, PromiseState.FULFILLED), this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n        return;\n      } else if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        // 2.3.3\n        try {\n          // 2.3.3.1\n          var then = newValue['then'];\n        } catch (e) {\n          // 2.3.3.2\n          this.state_ = PromiseState.REJECTED;\n          this.value_ = e;\n          this.scheduleNotifications_();\n          return;\n        }\n\n        if (typeof then === 'function') {\n          // 2.3.3.3\n          this.invokeThen_(\n          /** @type {!Object} */\n          newValue, then);\n          return;\n        }\n      }\n    }\n\n    if (newState === PromiseState.REJECTED && isError(newValue) && newValue.stack && this.stack_) {\n      newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n    } // 2.3.3.4 and 2.3.4\n\n\n    this.state_ = newState;\n    this.value_ = newValue;\n    this.scheduleNotifications_();\n  }\n  /**\n   * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n   * A+ spec.\n   * @param {!Object} x The thenable object.\n   * @param {!Function} then The \"then\" function to invoke.\n   * @private\n   */\n\n\n  invokeThen_(x, then) {\n    var called = false;\n    var self = this;\n\n    var resolvePromise = function (value) {\n      if (!called) {\n        // 2.3.3.3.3\n        called = true; // 2.3.3.3.1\n\n        self.unblockAndResolve_(PromiseState.FULFILLED, value);\n      }\n    };\n\n    var rejectPromise = function (reason) {\n      if (!called) {\n        // 2.3.3.3.3\n        called = true; // 2.3.3.3.2\n\n        self.unblockAndResolve_(PromiseState.REJECTED, reason);\n      }\n    };\n\n    try {\n      // 2.3.3.3\n      then.call(x, resolvePromise, rejectPromise);\n    } catch (e) {\n      // 2.3.3.3.4.2\n      rejectPromise(e);\n    }\n  }\n  /**\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @private\n   */\n\n\n  unblockAndResolve_(newState, newValue) {\n    if (this.state_ === PromiseState.BLOCKED) {\n      this.state_ = PromiseState.PENDING;\n      this.resolve_(newState, newValue);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  scheduleNotifications_() {\n    vlog(2, () => this + ' scheduling notifications', this);\n    ON_CANCEL_HANDLER.delete(this);\n\n    if (this.value_ instanceof CancellationError && this.value_.silent_) {\n      this.callbacks_ = null;\n    }\n\n    if (!this.queue_) {\n      this.queue_ = this.flow_.getActiveQueue_();\n    }\n\n    if (!this.handled_ && this.state_ === PromiseState.REJECTED && !(this.value_ instanceof CancellationError)) {\n      this.queue_.addUnhandledRejection(this);\n    }\n\n    this.queue_.scheduleCallbacks(this);\n  }\n  /** @override */\n\n\n  cancel(opt_reason) {\n    if (!canCancel(this)) {\n      return;\n    }\n\n    if (this.parent_ && canCancel(this.parent_)) {\n      /** @type {!CancellableThenable} */\n      this.parent_.cancel(opt_reason);\n    } else {\n      var reason = CancellationError.wrap(opt_reason);\n      let onCancel = ON_CANCEL_HANDLER.get(this);\n\n      if (onCancel) {\n        onCancel(reason);\n        ON_CANCEL_HANDLER.delete(this);\n      }\n\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.unblockAndResolve_(PromiseState.REJECTED, reason);\n      } else {\n        this.resolve_(PromiseState.REJECTED, reason);\n      }\n    }\n\n    function canCancel(promise) {\n      if (!(promise instanceof ManagedPromise)) {\n        return CancellableThenable.isImplementation(promise);\n      }\n\n      return promise.state_ === PromiseState.PENDING || promise.state_ === PromiseState.BLOCKED;\n    }\n  }\n  /** @override */\n\n\n  then(opt_callback, opt_errback) {\n    return this.addCallback_(opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n  }\n  /** @override */\n\n\n  catch(errback) {\n    return this.addCallback_(null, errback, 'catch', ManagedPromise.prototype.catch);\n  }\n  /**\n   * @param {function(): (R|IThenable<R>)} callback\n   * @return {!ManagedPromise<R>}\n   * @template R\n   * @see ./promise.finally()\n   */\n\n\n  finally(callback) {\n    let result = thenFinally(this, callback);\n    return (\n      /** @type {!ManagedPromise} */\n      result\n    );\n  }\n  /**\n   * Registers a new callback with this promise\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @param {string} name The callback name.\n   * @param {!Function} fn The function to use as the top of the stack when\n   *     recording the callback's creation point.\n   * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n   *     result of the invoked callback.\n   * @template R\n   * @private\n   */\n\n\n  addCallback_(callback, errback, name, fn) {\n    if (typeof callback !== 'function' && typeof errback !== 'function') {\n      return this;\n    }\n\n    this.handled_ = true;\n\n    if (this.queue_) {\n      this.queue_.clearUnhandledRejection(this);\n    }\n\n    var cb = new Task(this.flow_, this.invokeCallback_.bind(this, callback, errback), name, LONG_STACK_TRACES ? {\n      name: 'Promise',\n      top: fn\n    } : undefined);\n    cb.promise.parent_ = this;\n\n    if (this.state_ !== PromiseState.PENDING && this.state_ !== PromiseState.BLOCKED) {\n      this.flow_.getActiveQueue_().enqueue(cb);\n    } else {\n      if (!this.callbacks_) {\n        this.callbacks_ = [];\n      }\n\n      this.callbacks_.push(cb);\n      cb.blocked = true;\n      this.flow_.getActiveQueue_().enqueue(cb);\n    }\n\n    return cb.promise;\n  }\n  /**\n   * Invokes a callback function attached to this promise.\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @template R\n   * @private\n   */\n\n\n  invokeCallback_(callback, errback) {\n    var callbackFn = callback;\n\n    if (this.state_ === PromiseState.REJECTED) {\n      callbackFn = errback;\n    }\n\n    if (typeof callbackFn === 'function') {\n      if (isGenerator(callbackFn)) {\n        return consume(callbackFn, null, this.value_);\n      }\n\n      return callbackFn(this.value_);\n    } else if (this.state_ === PromiseState.REJECTED) {\n      throw this.value_;\n    } else {\n      return this.value_;\n    }\n  }\n\n}\n\nCancellableThenable.addImplementation(ManagedPromise);\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\n\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\n\n\nfunction Resolver() {}\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\n\n\nResolver.prototype.promise;\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\n\nResolver.prototype.resolve;\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\n\nResolver.prototype.reject;\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\n\nclass Deferred {\n  /**\n   * @param {ControlFlow=} opt_flow The control flow this instance was\n   *     created under. This should only be provided during unit tests.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(opt_flow, opt_skipLog) {\n    var fulfill, reject;\n    /** @type {!ManagedPromise<T>} */\n\n    this.promise = new ManagedPromise(function (f, r) {\n      fulfill = f;\n      reject = r;\n    }, opt_flow, opt_skipLog);\n    var self = this;\n\n    var checkNotSelf = function (value) {\n      if (value === self) {\n        throw new TypeError('May not resolve a Deferred with itself');\n      }\n    };\n    /**\n     * Resolves this deferred with the given value. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n     * @const\n     */\n\n\n    this.resolve = function (opt_value) {\n      checkNotSelf(opt_value);\n      fulfill(opt_value);\n    };\n    /**\n     * An alias for {@link #resolve}.\n     * @const\n     */\n\n\n    this.fulfill = this.resolve;\n    /**\n     * Rejects this promise with the given reason. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {*=} opt_reason The rejection reason.\n     * @const\n     */\n\n    this.reject = function (opt_reason) {\n      checkNotSelf(opt_reason);\n      reject(opt_reason);\n    };\n  }\n\n}\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\n\n\nfunction isError(value) {\n  return value instanceof Error || !!value && typeof value === 'object' && typeof value.message === 'string';\n}\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\n\n\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value && (typeof value === 'object' || typeof value === 'function') && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\n\n\nfunction delayed(ms) {\n  return createPromise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\n\n\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n\n  let resolve, reject;\n  let promise = new NativePromise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\n\n\nfunction fulfilled(opt_value) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n\n  if (opt_value instanceof ctor) {\n    return (\n      /** @type {!Thenable} */\n      opt_value\n    );\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(resolve => resolve(opt_value), undefined, SKIP_LOG);\n  }\n\n  return NativePromise.resolve(opt_value);\n}\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\n\n\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise((_, reject) => reject(opt_reason), undefined, SKIP_LOG);\n  }\n\n  return NativePromise.reject(opt_reason);\n}\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\n\n\nfunction checkedNodeCall(fn, var_args) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function (fulfill, reject) {\n    try {\n      args.push(function (error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\n\n\nfunction thenFinally(promise, callback) {\n  let error;\n  let mustThrow = false;\n  return promise.then(function () {\n    return callback();\n  }, function (err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function () {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\n\n\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\n\n\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n  } else if (callback) {\n    callback(value);\n  }\n}\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\n\n\nfunction all(arr) {\n  return createPromise(function (fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n\n    var onFulfilled = function (index, value) {\n      values[index] = value;\n      toFulfill--;\n\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function (value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction map(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr =\n    /** @type {!Array} */\n    v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          asap(fn.call(opt_self, arr[i], i,\n          /** @type {!Array} */\n          arr), function (value) {\n            values[i] = value;\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction filter(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr =\n    /** @type {!Array} */\n    v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i,\n          /** @type {!Array} */\n          arr);\n          asap(include, function (include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n\n  return fullyResolveValue(value);\n}\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(\n    /** @type {!Array} */\n    value);\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return (\n        /** @type {!ManagedPromise} */\n        value\n      );\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(\n    /** @type {!Object} */\n    value);\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(\n    /** @type {!Object} */\n    value);\n  }\n\n  return createPromise(resolve => resolve(value));\n}\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\n\n\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : function () {\n    let n = 0;\n\n    for (let key in obj) {\n      n += 1;\n    }\n\n    return n;\n  }();\n\n  if (!numKeys) {\n    return createPromise(resolve => resolve(obj));\n  }\n\n  function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function (fulfill, reject) {\n    var forEachKey = isArray ? forEachElement : forEachProperty;\n    forEachKey(obj, function (partialValue, key) {\n      if (!Array.isArray(partialValue) && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(function (resolvedValue) {\n        obj[key] = resolvedValue;\n        maybeResolveValue();\n      }, reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n} //////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\n\n\nclass Scheduler {\n  /**\n   * Schedules a task for execution. If the task function is a generator, the\n   * task will be executed using {@link ./promise.consume consume()}.\n   *\n   * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n   *     task.\n   * @param {string=} opt_description A description of the task for debugging\n   *     purposes.\n   * @return {!Thenable<T>} A promise that will be resolved with the task\n   *     result.\n   * @template T\n   */\n  execute(fn, opt_description) {}\n  /**\n   * Creates a new promise using the given resolver function.\n   *\n   * @param {function(\n   *             function((T|IThenable<T>|Thenable|null)=),\n   *             function(*=))} resolver\n   * @return {!Thenable<T>}\n   * @template T\n   */\n\n\n  promise(resolver) {}\n  /**\n   * Schedules a `setTimeout` call.\n   *\n   * @param {number} ms The timeout delay, in milliseconds.\n   * @param {string=} opt_description A description to accompany the timeout.\n   * @return {!Thenable<void>} A promise that will be resolved when the timeout\n   *     fires.\n   */\n\n\n  timeout(ms, opt_description) {}\n  /**\n   * Schedules a task to wait for a condition to hold.\n   *\n   * If the condition is defined as a function, it may return any value. Promise\n   * will be resolved before testing if the condition holds (resolution time\n   * counts towards the timeout). Once resolved, values are always evaluated as\n   * booleans.\n   *\n   * If the condition function throws, or returns a rejected promise, the\n   * wait task will fail.\n   *\n   * If the condition is defined as a promise, the scheduler will wait for it to\n   * settle. If the timeout expires before the promise settles, the promise\n   * returned by this function will be rejected.\n   *\n   * If this function is invoked with `timeout === 0`, or the timeout is\n   * omitted, this scheduler will wait indefinitely for the condition to be\n   * satisfied.\n   *\n   * @param {(!IThenable<T>|function())} condition The condition to poll,\n   *     or a promise to wait on.\n   * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n   *     condition to hold before timing out. If omitted, the flow will wait\n   *     indefinitely.\n   * @param {string=} opt_message An optional error message to include if the\n   *     wait times out; defaults to the empty string.\n   * @return {!Thenable<T>} A promise that will be fulfilled\n   *     when the condition has been satisfied. The promise shall be rejected\n   *     if the wait times out waiting for the condition.\n   * @throws {TypeError} If condition is not a function or promise or if timeout\n   *     is not a number >= 0.\n   * @template T\n   */\n\n\n  wait(condition, opt_timeout, opt_message) {}\n\n}\n\nlet USE_PROMISE_MANAGER;\n\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\n\n\nfunction createPromise(resolver) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\n\n\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  let timeout = opt_timeout || 0;\n\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function () {\n      if (!timeout) {\n        return condition;\n      }\n\n      return scheduler.promise(function (fulfill, reject) {\n        let start = Date.now();\n        let timer = setTimeout(function () {\n          timer = null;\n          reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + 'Timed out waiting for promise to resolve after ' + (Date.now() - start) + 'ms'));\n        }, timeout);\n        /** @type {Thenable} */\n\n        condition.then(function (value) {\n          timer && clearTimeout(timer);\n          fulfill(value);\n        }, function (error) {\n          timer && clearTimeout(timer);\n          reject(error);\n        });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' + typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    let original = condition;\n\n    condition = () => consume(original);\n  }\n\n  return scheduler.execute(function () {\n    var startTime = Date.now();\n    return scheduler.promise(function (fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn =\n        /** @type {function()} */\n        condition;\n        scheduler.execute(conditionFn).then(function (value) {\n          var elapsed = Date.now() - startTime;\n\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + `Wait timed out after ${elapsed}ms`));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\n\n\nclass SimpleScheduler extends events.EventEmitter {\n  /** @override */\n  execute(fn) {\n    return this.promise((resolve, reject) => {\n      try {\n        if (isGenerator(fn)) {\n          consume(fn).then(resolve, reject);\n        } else {\n          resolve(fn.call(undefined));\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    });\n  }\n  /** @override */\n\n\n  promise(resolver) {\n    return new NativePromise(resolver);\n  }\n  /** @override */\n\n\n  timeout(ms) {\n    return this.promise(resolve => setTimeout(_ => resolve(), ms));\n  }\n  /** @override */\n\n\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n\n}\n\nconst SIMPLE_SCHEDULER = new SimpleScheduler();\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\n\nclass ControlFlow extends events.EventEmitter {\n  constructor() {\n    if (!usePromiseManager()) {\n      throw TypeError('Cannot instantiate control flow when the promise manager has' + ' been disabled');\n    }\n\n    super();\n    /** @private {boolean} */\n\n    this.propagateUnhandledRejections_ = true;\n    /** @private {TaskQueue} */\n\n    this.activeQueue_ = null;\n    /** @private {Set<TaskQueue>} */\n\n    this.taskQueues_ = null;\n    /**\n     * Microtask that controls shutting down the control flow. Upon shut down,\n     * the flow will emit an\n     * {@link ControlFlow.EventType.IDLE} event. Idle events\n     * always follow a brief timeout in order to catch latent errors from the\n     * last completed task. If this task had a callback registered, but no\n     * errback, and the task fails, the unhandled failure would not be reported\n     * by the promise system until the next turn of the event loop:\n     *\n     *   // Schedule 1 task that fails.\n     *   var result = promise.controlFlow().execute(\n     *       () => promise.rejected('failed'), 'example');\n     *   // Set a callback on the result. This delays reporting the unhandled\n     *   // failure for 1 turn of the event loop.\n     *   result.then(function() {});\n     *\n     * @private {MicroTask}\n     */\n\n    this.shutdownTask_ = null;\n    /**\n     * ID for a long running interval used to keep a Node.js process running\n     * while a control flow's event loop is still working. This is a cheap hack\n     * required since JS events are only scheduled to run when there is\n     * _actually_ something to run. When a control flow is waiting on a task,\n     * there will be nothing in the JS event loop and the process would\n     * terminate without this.\n     * @private\n     */\n\n    this.hold_ = null;\n  }\n  /**\n   * Returns a string representation of this control flow, which is its current\n   * {@linkplain #getSchedule() schedule}, sans task stack traces.\n   * @return {string} The string representation of this control flow.\n   * @override\n   */\n\n\n  toString() {\n    return this.getSchedule();\n  }\n  /**\n   * Sets whether any unhandled rejections should propagate up through the\n   * control flow stack and cause rejections within parent tasks. If error\n   * propagation is disabled, tasks will not be aborted when an unhandled\n   * promise rejection is detected, but the rejection _will_ trigger an\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * The default behavior is to propagate all unhandled rejections. _The use\n   * of this option is highly discouraged._\n   *\n   * @param {boolean} propagate whether to propagate errors.\n   */\n\n\n  setPropagateUnhandledRejections(propagate) {\n    this.propagateUnhandledRejections_ = propagate;\n  }\n  /**\n   * @return {boolean} Whether this flow is currently idle.\n   */\n\n\n  isIdle() {\n    return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n  }\n  /**\n   * Resets this instance, clearing its queue and removing all event listeners.\n   */\n\n\n  reset() {\n    this.cancelQueues_(new FlowResetError());\n    this.emit(ControlFlow.EventType.RESET);\n    this.removeAllListeners();\n    this.cancelShutdown_();\n  }\n  /**\n   * Generates an annotated string describing the internal state of this control\n   * flow, including the currently executing as well as pending tasks. If\n   * {@code opt_includeStackTraces === true}, the string will include the\n   * stack trace from when each task was scheduled.\n   * @param {string=} opt_includeStackTraces Whether to include the stack traces\n   * from when each task was scheduled. Defaults to false.\n   * @return {string} String representation of this flow's internal state.\n   */\n\n\n  getSchedule(opt_includeStackTraces) {\n    var ret = 'ControlFlow::' + getUid(this);\n    var activeQueue = this.activeQueue_;\n\n    if (!this.taskQueues_ || !this.taskQueues_.size) {\n      return ret;\n    }\n\n    var childIndent = '| ';\n\n    for (var q of this.taskQueues_) {\n      ret += '\\n' + printQ(q, childIndent);\n    }\n\n    return ret;\n\n    function printQ(q, indent) {\n      var ret = q.toString();\n\n      if (q === activeQueue) {\n        ret = '(active) ' + ret;\n      }\n\n      var prefix = indent + childIndent;\n\n      if (q.pending_) {\n        if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n          ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n          ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n        } else {\n          ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n        }\n      }\n\n      if (q.interrupts_) {\n        q.interrupts_.forEach(task => {\n          ret += '\\n' + prefix + task;\n        });\n      }\n\n      if (q.tasks_) {\n        q.tasks_.forEach(task => ret += printTask(task, '\\n' + prefix));\n      }\n\n      return indent + ret;\n    }\n\n    function printTask(task, prefix) {\n      var ret = prefix + task;\n\n      if (opt_includeStackTraces && task.promise.stack_) {\n        ret += prefix + childIndent + (task.promise.stack_.stack || task.promise.stack_).replace(/\\n/g, prefix);\n      }\n\n      return ret;\n    }\n  }\n  /**\n   * Returns the currently active task queue for this flow. If there is no\n   * active queue, one will be created.\n   * @return {!TaskQueue} the currently active task queue for this flow.\n   * @private\n   */\n\n\n  getActiveQueue_() {\n    if (this.activeQueue_) {\n      return this.activeQueue_;\n    }\n\n    this.activeQueue_ = new TaskQueue(this);\n\n    if (!this.taskQueues_) {\n      this.taskQueues_ = new Set();\n    }\n\n    this.taskQueues_.add(this.activeQueue_);\n    this.activeQueue_.once('end', this.onQueueEnd_, this).once('error', this.onQueueError_, this);\n    asyncRun(() => this.activeQueue_ = null);\n    this.activeQueue_.start();\n    return this.activeQueue_;\n  }\n  /** @override */\n\n\n  execute(fn, opt_description) {\n    if (isGenerator(fn)) {\n      let original = fn;\n\n      fn = () => consume(original);\n    }\n\n    if (!this.hold_) {\n      let holdIntervalMs = 2147483647; // 2^31-1; max timer length for Node.js\n\n      this.hold_ = setInterval(function () {}, holdIntervalMs);\n    }\n\n    let task = new Task(this, fn, opt_description || '<anonymous>', {\n      name: 'Task',\n      top: ControlFlow.prototype.execute\n    }, true);\n    let q = this.getActiveQueue_();\n\n    for (let i = q.tasks_.length; i > 0; i--) {\n      let previousTask = q.tasks_[i - 1];\n\n      if (previousTask.userTask_) {\n        FLOW_LOG.warning(() => {\n          return `Detected scheduling of an unchained task.\nWhen the promise manager is disabled, unchained tasks will not wait for\npreviously scheduled tasks to finish before starting to execute.\nNew task: ${task.promise.stack_.stack}\nPrevious task: ${previousTask.promise.stack_.stack}`.split(/\\n/).join('\\n    ');\n        });\n        break;\n      }\n    }\n\n    q.enqueue(task);\n    this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n    return task.promise;\n  }\n  /** @override */\n\n\n  promise(resolver) {\n    return new ManagedPromise(resolver, this, SKIP_LOG);\n  }\n  /** @override */\n\n\n  timeout(ms, opt_description) {\n    return this.execute(() => {\n      return this.promise(resolve => setTimeout(() => resolve(), ms));\n    }, opt_description);\n  }\n  /** @override */\n\n\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n  /**\n   * Executes a function in the next available turn of the JavaScript event\n   * loop. This ensures the function runs with its own task queue and any\n   * scheduled tasks will run in \"parallel\" to those scheduled in the current\n   * function.\n   *\n   *     flow.execute(() => console.log('a'));\n   *     flow.execute(() => console.log('b'));\n   *     flow.execute(() => console.log('c'));\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('d'));\n   *        flow.execute(() => console.log('e'));\n   *     });\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('f'));\n   *        flow.execute(() => console.log('g'));\n   *     });\n   *     flow.once('idle', () => console.log('fin'));\n   *     // a\n   *     // d\n   *     // f\n   *     // b\n   *     // e\n   *     // g\n   *     // c\n   *     // fin\n   *\n   * If the function itself throws, the error will be treated the same as an\n   * unhandled rejection within the control flow.\n   *\n   * __NOTE__: This function is considered _unstable_.\n   *\n   * @param {!Function} fn The function to execute.\n   * @param {Object=} opt_self The object in whose context to run the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   */\n\n\n  async(fn, opt_self, var_args) {\n    asyncRun(() => {\n      // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n      this.activeQueue_ = null;\n      var q = this.getActiveQueue_();\n\n      try {\n        q.execute_(fn.bind(opt_self, var_args));\n      } catch (ex) {\n        var cancellationError = CancellationError.wrap(ex, 'Function passed to ControlFlow.async() threw');\n        cancellationError.silent_ = true;\n        q.abort_(cancellationError);\n      } finally {\n        this.activeQueue_ = null;\n      }\n    });\n  }\n  /**\n   * Event handler for when a task queue is exhausted. This starts the shutdown\n   * sequence for this instance if there are no remaining task queues: after\n   * one turn of the event loop, this object will emit the\n   * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n   * listeners that it has completed. During this wait, if another task is\n   * scheduled, the shutdown will be aborted.\n   *\n   * @param {!TaskQueue} q the completed task queue.\n   * @private\n   */\n\n\n  onQueueEnd_(q) {\n    if (!this.taskQueues_) {\n      return;\n    }\n\n    this.taskQueues_.delete(q);\n    vlog(1, () => q + ' has finished');\n    vlog(1, () => this.taskQueues_.size + ' queues remain\\n' + this, this);\n\n    if (!this.taskQueues_.size) {\n      if (this.shutdownTask_) {\n        throw Error('Already have a shutdown task??');\n      }\n\n      vlog(1, () => 'Scheduling shutdown\\n' + this);\n      this.shutdownTask_ = new MicroTask(() => this.shutdown_());\n    }\n  }\n  /**\n   * Event handler for when a task queue terminates with an error. This triggers\n   * the cancellation of all other task queues and a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   * If there are no error event listeners registered with this instance, the\n   * error will be rethrown to the global error handler.\n   *\n   * @param {*} error the error that caused the task queue to terminate.\n   * @param {!TaskQueue} q the task queue.\n   * @private\n   */\n\n\n  onQueueError_(error, q) {\n    if (this.taskQueues_) {\n      this.taskQueues_.delete(q);\n    }\n\n    this.cancelQueues_(CancellationError.wrap(error, 'There was an uncaught error in the control flow'));\n    this.cancelShutdown_();\n    this.cancelHold_();\n    setTimeout(() => {\n      let listeners = this.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n\n      if (!listeners.size) {\n        throw error;\n      } else {\n        this.reportUncaughtException_(error);\n      }\n    }, 0);\n  }\n  /**\n   * Cancels all remaining task queues.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n\n\n  cancelQueues_(reason) {\n    reason.silent_ = true;\n\n    if (this.taskQueues_) {\n      for (var q of this.taskQueues_) {\n        q.removeAllListeners();\n        q.abort_(reason);\n      }\n\n      this.taskQueues_.clear();\n      this.taskQueues_ = null;\n    }\n  }\n  /**\n   * Reports an uncaught exception using a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * @param {*} e the error to report.\n   * @private\n   */\n\n\n  reportUncaughtException_(e) {\n    this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n  }\n  /** @private */\n\n\n  cancelHold_() {\n    if (this.hold_) {\n      clearInterval(this.hold_);\n      this.hold_ = null;\n    }\n  }\n  /** @private */\n\n\n  shutdown_() {\n    vlog(1, () => 'Going idle: ' + this);\n    this.cancelHold_();\n    this.shutdownTask_ = null;\n    this.emit(ControlFlow.EventType.IDLE);\n  }\n  /**\n   * Cancels the shutdown sequence if it is currently scheduled.\n   * @private\n   */\n\n\n  cancelShutdown_() {\n    if (this.shutdownTask_) {\n      this.shutdownTask_.cancel();\n      this.shutdownTask_ = null;\n    }\n  }\n\n}\n/**\n * Events that may be emitted by an {@link ControlFlow}.\n * @enum {string}\n */\n\n\nControlFlow.EventType = {\n  /** Emitted when all tasks have been successfully executed. */\n  IDLE: 'idle',\n\n  /** Emitted when a ControlFlow has been reset. */\n  RESET: 'reset',\n\n  /** Emitted whenever a new task has been scheduled. */\n  SCHEDULE_TASK: 'scheduleTask',\n\n  /**\n   * Emitted whenever a control flow aborts due to an unhandled promise\n   * rejection. This event will be emitted along with the offending rejection\n   * reason. Upon emitting this event, the control flow will empty its task\n   * queue and revert to its initial state.\n   */\n  UNCAUGHT_EXCEPTION: 'uncaughtException'\n};\n/**\n * Wraps a function to execute as a cancellable micro task.\n * @final\n */\n\nclass MicroTask {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  constructor(fn) {\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(() => {\n      if (!this.cancelled_) {\n        fn();\n      }\n    });\n  }\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n\n\n  static run(fn) {\n    NativePromise.resolve().then(function () {\n      try {\n        fn();\n      } catch (ignored) {// Do nothing.\n      }\n    });\n  }\n  /**\n   * Cancels the execution of this task. Note: this will not prevent the task\n   * timer from firing, just the invocation of the wrapped function.\n   */\n\n\n  cancel() {\n    this.cancelled_ = true;\n  }\n\n}\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\n\n\nclass Task extends Deferred {\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  constructor(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    super(flow, SKIP_LOG);\n    getUid(this);\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n\n    this.execute = fn;\n    /** @type {string} */\n\n    this.description = description;\n    /** @type {TaskQueue} */\n\n    this.queue = null;\n    /** @private @const {boolean} */\n\n    this.userTask_ = !!opt_isUserTask;\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n\n    this.blocked = false;\n\n    if (opt_stackOptions) {\n      this.promise.stack_ = captureStackTrace(opt_stackOptions.name, this.description, opt_stackOptions.top);\n    }\n  }\n  /** @override */\n\n\n  toString() {\n    return 'Task::' + getUid(this) + '<' + this.description + '>';\n  }\n\n}\n/** @enum {string} */\n\n\nconst TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n/**\n * @final\n */\n\nclass TaskQueue extends events.EventEmitter {\n  /** @param {!ControlFlow} flow . */\n  constructor(flow) {\n    super();\n    /** @private {string} */\n\n    this.name_ = 'TaskQueue::' + getUid(this);\n    /** @private {!ControlFlow} */\n\n    this.flow_ = flow;\n    /** @private {!Array<!Task>} */\n\n    this.tasks_ = [];\n    /** @private {Array<!Task>} */\n\n    this.interrupts_ = null;\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n\n    this.pending_ = null;\n    /** @private {TaskQueue} */\n\n    this.subQ_ = null;\n    /** @private {TaskQueueState} */\n\n    this.state_ = TaskQueueState.NEW;\n    /** @private {!Set<!ManagedPromise>} */\n\n    this.unhandledRejections_ = new Set();\n  }\n  /** @override */\n\n\n  toString() {\n    return 'TaskQueue::' + getUid(this);\n  }\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n\n\n  addUnhandledRejection(promise) {\n    // TODO: node 4.0.0+\n    vlog(2, () => this + ' registering unhandled rejection: ' + promise, this);\n    this.unhandledRejections_.add(promise);\n  }\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n\n\n  clearUnhandledRejection(promise) {\n    var deleted = this.unhandledRejections_.delete(promise);\n\n    if (deleted) {\n      // TODO: node 4.0.0+\n      vlog(2, () => this + ' clearing unhandled rejection: ' + promise, this);\n    }\n  }\n  /**\n   * Enqueues a new task for execution.\n   * @param {!Task} task The task to enqueue.\n   * @throws {Error} If this instance has already started execution.\n   */\n\n\n  enqueue(task) {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw Error('TaskQueue has started: ' + this);\n    }\n\n    if (task.queue) {\n      throw Error('Task is already scheduled in another queue');\n    }\n\n    this.tasks_.push(task);\n    task.queue = this;\n    ON_CANCEL_HANDLER.set(task.promise, e => this.onTaskCancelled_(task, e));\n    vlog(1, () => this + '.enqueue(' + task + ')', this);\n    vlog(2, () => this.flow_.toString(), this);\n  }\n  /**\n   * Schedules the callbacks registered on the given promise in this queue.\n   *\n   * @param {!ManagedPromise} promise the promise whose callbacks should be\n   *     registered as interrupts in this task queue.\n   * @throws {Error} if this queue has already finished.\n   */\n\n\n  scheduleCallbacks(promise) {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      throw new Error('cannot interrupt a finished q(' + this + ')');\n    }\n\n    if (this.pending_ && this.pending_.task.promise === promise) {\n      this.pending_.task.promise.queue_ = null;\n      this.pending_ = null;\n      asyncRun(() => this.executeNext_());\n    }\n\n    if (!promise.callbacks_) {\n      return;\n    }\n\n    promise.callbacks_.forEach(function (cb) {\n      cb.blocked = false;\n\n      if (cb.queue) {\n        return;\n      }\n\n      ON_CANCEL_HANDLER.set(cb.promise, e => this.onTaskCancelled_(cb, e));\n\n      if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n        return;\n      }\n\n      if (cb.queue) {\n        cb.queue.dropTask_(cb);\n      }\n\n      cb.queue = this;\n\n      if (!this.interrupts_) {\n        this.interrupts_ = [];\n      }\n\n      this.interrupts_.push(cb);\n    }, this);\n    promise.callbacks_ = null;\n    vlog(2, () => this + ' interrupted\\n' + this.flow_, this);\n  }\n  /**\n   * Starts executing tasks in this queue. Once called, no further tasks may\n   * be {@linkplain #enqueue() enqueued} with this instance.\n   *\n   * @throws {Error} if this queue has already been started.\n   */\n\n\n  start() {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw new Error('TaskQueue has already started');\n    } // Always asynchronously execute next, even if there doesn't look like\n    // there is anything in the queue. This will catch pending unhandled\n    // rejections that were registered before start was called.\n\n\n    asyncRun(() => this.executeNext_());\n  }\n  /**\n   * Aborts this task queue. If there are any scheduled tasks, they are silently\n   * cancelled and discarded (their callbacks will never fire). If this queue\n   * has a _pending_ task, the abortion error is used to cancel that task.\n   * Otherwise, this queue will emit an error event.\n   *\n   * @param {*} error The abortion reason.\n   * @private\n   */\n\n\n  abort_(error) {\n    var cancellation;\n\n    if (error instanceof FlowResetError) {\n      cancellation = error;\n    } else {\n      cancellation = new DiscardedTaskError(error);\n    }\n\n    if (this.interrupts_ && this.interrupts_.length) {\n      this.interrupts_.forEach(t => t.reject(cancellation));\n      this.interrupts_ = [];\n    }\n\n    if (this.tasks_ && this.tasks_.length) {\n      this.tasks_.forEach(t => t.reject(cancellation));\n      this.tasks_ = [];\n    } // Now that all of the remaining tasks have been silently cancelled (e.g. no\n    // existing callbacks on those tasks will fire), clear the silence bit on\n    // the cancellation error. This ensures additional callbacks registered in\n    // the future will actually execute.\n\n\n    cancellation.silent_ = false;\n\n    if (this.pending_) {\n      vlog(2, () => this + '.abort(); cancelling pending task', this);\n      this.pending_.task.promise.cancel(\n      /** @type {!CancellationError} */\n      error);\n    } else {\n      vlog(2, () => this + '.abort(); emitting error event', this);\n      this.emit('error', error, this);\n    }\n  }\n  /** @private */\n\n\n  executeNext_() {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      return;\n    }\n\n    this.state_ = TaskQueueState.STARTED;\n\n    if (this.pending_ !== null || this.processUnhandledRejections_()) {\n      return;\n    }\n\n    var task;\n\n    do {\n      task = this.getNextTask_();\n    } while (task && !isPending(task.promise));\n\n    if (!task) {\n      this.state_ = TaskQueueState.FINISHED;\n      this.tasks_ = [];\n      this.interrupts_ = null;\n      vlog(2, () => this + '.emit(end)', this);\n      this.emit('end', this);\n      return;\n    }\n\n    let result = undefined;\n    this.subQ_ = new TaskQueue(this.flow_);\n    this.subQ_.once('end', () => {\n      // On task completion.\n      this.subQ_ = null;\n      this.pending_ && this.pending_.task.resolve(result);\n    });\n    this.subQ_.once('error', e => {\n      // On task failure.\n      this.subQ_ = null;\n\n      if (Thenable.isImplementation(result)) {\n        result.cancel(CancellationError.wrap(e));\n      }\n\n      this.pending_ && this.pending_.task.reject(e);\n    });\n    vlog(2, () => `${this} created ${this.subQ_} for ${task}`);\n\n    try {\n      this.pending_ = {\n        task: task,\n        q: this.subQ_\n      };\n      task.promise.queue_ = this;\n      result = this.subQ_.execute_(task.execute);\n      this.subQ_.start();\n    } catch (ex) {\n      this.subQ_.abort_(ex);\n    }\n  }\n  /**\n   * @param {!Function} fn .\n   * @return {T} .\n   * @template T\n   * @private\n   */\n\n\n  execute_(fn) {\n    try {\n      activeFlows.push(this.flow_);\n      this.flow_.activeQueue_ = this;\n      return fn();\n    } finally {\n      this.flow_.activeQueue_ = null;\n      activeFlows.pop();\n    }\n  }\n  /**\n   * Process any unhandled rejections registered with this task queue. If there\n   * is a rejection, this queue will be aborted with the rejection error. If\n   * there are multiple rejections registered, this queue will be aborted with\n   * a {@link MultipleUnhandledRejectionError}.\n   * @return {boolean} whether there was an unhandled rejection.\n   * @private\n   */\n\n\n  processUnhandledRejections_() {\n    if (!this.unhandledRejections_.size) {\n      return false;\n    }\n\n    var errors = new Set();\n\n    for (var rejection of this.unhandledRejections_) {\n      errors.add(rejection.value_);\n    }\n\n    this.unhandledRejections_.clear();\n    var errorToReport = errors.size === 1 ? errors.values().next().value : new MultipleUnhandledRejectionError(errors);\n    vlog(1, () => this + ' aborting due to unhandled rejections', this);\n\n    if (this.flow_.propagateUnhandledRejections_) {\n      this.abort_(errorToReport);\n      return true;\n    } else {\n      vlog(1, 'error propagation disabled; reporting to control flow');\n      this.flow_.reportUncaughtException_(errorToReport);\n      return false;\n    }\n  }\n  /**\n   * @param {!Task} task The task to drop.\n   * @private\n   */\n\n\n  dropTask_(task) {\n    var index;\n\n    if (this.interrupts_) {\n      index = this.interrupts_.indexOf(task);\n\n      if (index != -1) {\n        task.queue = null;\n        this.interrupts_.splice(index, 1);\n        return;\n      }\n    }\n\n    index = this.tasks_.indexOf(task);\n\n    if (index != -1) {\n      task.queue = null;\n      this.tasks_.splice(index, 1);\n    }\n  }\n  /**\n   * @param {!Task} task The task that was cancelled.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n\n\n  onTaskCancelled_(task, reason) {\n    if (this.pending_ && this.pending_.task === task) {\n      this.pending_.q.abort_(reason);\n    } else {\n      this.dropTask_(task);\n    }\n  }\n  /**\n   * @return {(Task|undefined)} the next task scheduled within this queue,\n   *     if any.\n   * @private\n   */\n\n\n  getNextTask_() {\n    var task = undefined;\n\n    while (true) {\n      if (this.interrupts_) {\n        task = this.interrupts_.shift();\n      }\n\n      if (!task && this.tasks_) {\n        task = this.tasks_.shift();\n      }\n\n      if (task && task.blocked) {\n        vlog(2, () => this + ' skipping blocked task ' + task, this);\n        task.queue = null;\n        task = null; // TODO: recurse when tail-call optimization is available in node.\n      } else {\n        break;\n      }\n    }\n\n    return task;\n  }\n\n}\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\n\n\nvar defaultFlow;\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\n\nvar activeFlows = [];\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\n\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error('You  may not change set the control flow when the promise' + ' manager is disabled');\n  }\n\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n\n  defaultFlow = flow;\n}\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\n\n\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow();\n  }\n\n  return defaultFlow;\n}\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\n\n\nfunction createFlow(callback) {\n  var flow = new ControlFlow();\n  return flow.execute(function () {\n    return callback(flow);\n  });\n}\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\n\n\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\n\n\nfunction consume(generatorFn, opt_self, ...var_args) {\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' + generatorFn.constructor.name);\n  }\n\n  let ret;\n  return ret = createPromise((resolve, reject) => {\n    let generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n    /** @param {*=} opt_value . */\n\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n    /** @param {*=} opt_error . */\n\n\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return; // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n} // PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() {\n    return usePromiseManager();\n  },\n\n  set USE_PROMISE_MANAGER(\n  /** boolean */\n  value) {\n    USE_PROMISE_MANAGER = value;\n  },\n\n  get LONG_STACK_TRACES() {\n    return LONG_STACK_TRACES;\n  },\n\n  set LONG_STACK_TRACES(v) {\n    LONG_STACK_TRACES = v;\n  }\n\n};","map":{"version":3,"sources":["/Users/dariya/Documents/GitHub/Web-development/lab 4&5/wgg87w--run/node_modules/selenium-webdriver/lib/promise.js"],"names":["error","require","events","logging","NativePromise","Promise","LONG_STACK_TRACES","LOG","getLogger","UNIQUE_IDS","WeakMap","nextId","getUid","obj","id","get","set","asyncRun","fn","resolve","then","ignored","vlog","level","loggable","opt_self","logLevel","Level","FINE","FINEST","FINER","bind","log","captureStackTrace","name","msg","opt_topFn","e","Error","stack","toString","CancellationError","constructor","opt_msg","silent_","wrap","message","FlowResetError","DiscardedTaskError","MultipleUnhandledRejectionError","errors","IMPLEMENTED_BY_SYMBOL","Symbol","CANCELLABLE_SYMBOL","addMarkerSymbol","ctor","symbol","prototype","hasMarkerSymbol","object","Thenable","addImplementation","isImplementation","opt_callback","opt_errback","catch","errback","CancellableThenable","cancel","opt_reason","PromiseState","PENDING","BLOCKED","REJECTED","FULFILLED","ON_CANCEL_HANDLER","SKIP_LOG","FLOW_LOG","ManagedPromise","resolver","opt_flow","opt_skipLog","usePromiseManager","TypeError","process","env","warning","flow_","controlFlow","stack_","parent_","callbacks_","state_","handled_","value_","undefined","queue_","self","value","resolve_","reason","ex","opt_value","reject","_","newState","newValue","unblockAndResolve_","scheduleNotifications_","invokeThen_","isError","x","called","resolvePromise","rejectPromise","call","delete","getActiveQueue_","addUnhandledRejection","scheduleCallbacks","canCancel","onCancel","promise","addCallback_","finally","callback","result","thenFinally","clearUnhandledRejection","cb","Task","invokeCallback_","top","enqueue","push","blocked","callbackFn","isGenerator","consume","isPending","Resolver","Deferred","fulfill","f","r","checkNotSelf","isPromise","delayed","ms","createPromise","setTimeout","defer","_resolve","_reject","fulfilled","rejected","checkedNodeCall","var_args","args","Array","slice","arguments","apply","mustThrow","err","when","asap","all","arr","n","length","values","toFulfill","onFulfilled","index","processPromise","i","map","v","isArray","processNext","filter","valuesLength","include","fullyResolved","fullyResolveValue","fullyResolveKeys","numKeys","key","forEachProperty","forEachElement","forEach","numResolved","forEachKey","partialValue","maybeResolveValue","resolvedValue","Scheduler","execute","opt_description","timeout","wait","condition","opt_timeout","opt_message","USE_PROMISE_MANAGER","test","scheduleWait","scheduler","start","Date","now","timer","TimeoutError","clearTimeout","original","startTime","pollCondition","conditionFn","elapsed","SimpleScheduler","EventEmitter","SIMPLE_SCHEDULER","ControlFlow","propagateUnhandledRejections_","activeQueue_","taskQueues_","shutdownTask_","hold_","getSchedule","setPropagateUnhandledRejections","propagate","isIdle","size","reset","cancelQueues_","emit","EventType","RESET","removeAllListeners","cancelShutdown_","opt_includeStackTraces","ret","activeQueue","childIndent","q","printQ","indent","prefix","pending_","TaskQueueState","FINISHED","task","interrupts_","tasks_","printTask","replace","TaskQueue","Set","add","once","onQueueEnd_","onQueueError_","holdIntervalMs","setInterval","previousTask","userTask_","split","join","SCHEDULE_TASK","description","async","execute_","cancellationError","abort_","MicroTask","shutdown_","cancelHold_","listeners","UNCAUGHT_EXCEPTION","reportUncaughtException_","clear","clearInterval","IDLE","cancelled_","run","flow","opt_stackOptions","opt_isUserTask","queue","NEW","STARTED","name_","subQ_","unhandledRejections_","deleted","onTaskCancelled_","executeNext_","indexOf","dropTask_","cancellation","t","processUnhandledRejections_","getNextTask_","activeFlows","pop","rejection","errorToReport","next","splice","shift","defaultFlow","setDefaultFlow","createFlow","generatorFn","generator","callNext","pump","callThrow","opt_error","throw","opt_arg","done","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,WAAD,CAAvB;AAGA;AACA;AACA;AACA;;;AACA,MAAMG,aAAa,GAAGC,OAAtB;AAGA;AACA;AACA;AACA;;AACA,IAAIC,iBAAiB,GAAG,KAAxB,C,CAAgC;;AAGhC;;AACA,MAAMC,GAAG,GAAGJ,OAAO,CAACK,SAAR,CAAkB,SAAlB,CAAZ;AAGA,MAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AACA,IAAIC,MAAM,GAAG,CAAb;;AAGA,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;AACnB,MAAIC,EAAE,GAAGL,UAAU,CAACM,GAAX,CAAeF,GAAf,CAAT;;AACA,MAAI,CAACC,EAAL,EAAS;AACPA,IAAAA,EAAE,GA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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, Key, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver', Key.RETURN);\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver', Key.RETURN);\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver', Key.RETURN);\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n\n'use strict';\n\nconst error = require('./error');\nconst events = require('./events');\nconst logging = require('./logging');\n\n\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\nconst NativePromise = Promise;\n\n\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\nvar LONG_STACK_TRACES = false;  // TODO: this should not be CONSTANT_CASE\n\n\n/** @const */\nconst LOG = logging.getLogger('promise');\n\n\nconst UNIQUE_IDS = new WeakMap;\nlet nextId = 1;\n\n\nfunction getUid(obj) {\n  let id = UNIQUE_IDS.get(obj);\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n  return id;\n}\n\n\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function() {\n    try {\n      fn();\n    } catch (ignored) {\n      // Do nothing.\n    }\n  });\n}\n\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n\n\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n  return e;\n}\n\n\n/**\n * Error used when the computation of a promise is cancelled.\n */\nclass CancellationError extends Error {\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  constructor(opt_msg) {\n    super(opt_msg);\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @private {boolean} */\n    this.silent_ = false;\n  }\n\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n  static wrap(error, opt_msg) {\n    var message;\n    if (error instanceof CancellationError) {\n      return new CancellationError(\n          opt_msg ? (opt_msg + ': ' + error.message) : error.message);\n    } else if (opt_msg) {\n      message = opt_msg;\n      if (error) {\n        message += ': ' + error;\n      }\n      return new CancellationError(message);\n    }\n    if (error) {\n      message = error + '';\n    }\n    return new CancellationError(message);\n  }\n}\n\n\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\nclass FlowResetError extends CancellationError {\n  constructor() {\n    super('ControlFlow was reset');\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\nclass DiscardedTaskError extends CancellationError {\n  /** @param {*} error The original error. */\n  constructor(error) {\n    if (error instanceof DiscardedTaskError) {\n      return /** @type {!DiscardedTaskError} */(error);\n    }\n\n    var msg = '';\n    if (error) {\n      msg = ': ' + (\n          typeof error.message === 'string' ? error.message : error);\n    }\n\n    super('Task was discarded due to a previous failure' + msg);\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\nclass MultipleUnhandledRejectionError extends Error {\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  constructor(errors) {\n    super('Multiple unhandled promise rejections reported');\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @type {!Set<*>} */\n    this.errors = errors;\n  }\n}\n\n\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\nconst IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nconst CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n\n\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {\n    // Property access denied?\n  }\n}\n\n\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false;  // Property access seems to be forbidden.\n  }\n}\n\n\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\nclass Thenable {\n  /**\n   * Adds a property to a class prototype to allow runtime checks of whether\n   * instances of that class implement the Thenable interface.\n   * @param {function(new: Thenable, ...?)} ctor The\n   *     constructor whose prototype to modify.\n   */\n  static addImplementation(ctor) {\n    addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Checks if an object has been tagged for implementing the Thenable\n   * interface as defined by {@link Thenable.addImplementation}.\n   * @param {*} object The object to test.\n   * @return {boolean} Whether the object is an implementation of the Thenable\n   *     interface.\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Registers listeners for when this instance is resolved.\n   *\n   * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n   *     function to call if this promise is successfully resolved. The function\n   *     should expect a single argument: the promise's resolved value.\n   * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n   *     The function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  then(opt_callback, opt_errback) {}\n\n  /**\n   * Registers a listener for when this promise is rejected. This is synonymous\n   * with the {@code catch} clause in a synchronous API:\n   *\n   *     // Synchronous API:\n   *     try {\n   *       doSynchronousWork();\n   *     } catch (ex) {\n   *       console.error(ex);\n   *     }\n   *\n   *     // Asynchronous promise API:\n   *     doAsynchronousWork().catch(function(ex) {\n   *       console.error(ex);\n   *     });\n   *\n   * @param {function(*): (R|IThenable<R>)} errback The\n   *     function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  catch(errback) {}\n}\n\n\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\nclass CancellableThenable {\n  /**\n   * @param {function(new: CancellableThenable, ...?)} ctor\n   */\n  static addImplementation(ctor) {\n    Thenable.addImplementation(ctor);\n    addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * @param {*} object\n   * @return {boolean}\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * Requests the cancellation of the computation of this promise's value,\n   * rejecting the promise in the process. This method is a no-op if the promise\n   * has already been resolved.\n   *\n   * @param {(string|Error)=} opt_reason The reason this promise is being\n   *     cancelled. This value will be wrapped in a {@link CancellationError}.\n   */\n  cancel(opt_reason) {}\n}\n\n\n/**\n * @enum {string}\n */\nconst PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n\n\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\nconst ON_CANCEL_HANDLER = new WeakMap;\n\nconst SKIP_LOG = Symbol('skip-log');\nconst FLOW_LOG = logging.getLogger('promise.ControlFlow');\n\n\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\nclass ManagedPromise {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(resolver, opt_flow, opt_skipLog) {\n    if (!usePromiseManager()) {\n      throw TypeError(\n        'Unable to create a managed promise instance: the promise manager has'\n            + ' been disabled by the SELENIUM_PROMISE_MANAGER environment'\n            + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(() => {\n        let e =\n            captureStackTrace(\n                'ManagedPromiseError',\n                'Creating a new managed Promise. This call will fail when the'\n                    + ' promise manager is disabled',\n            ManagedPromise)\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = opt_flow || controlFlow();\n\n    /** @private {Error} */\n    this.stack_ = null;\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n\n    /** @private {Thenable<?>} */\n    this.parent_ = null;\n\n    /** @private {Array<!Task>} */\n    this.callbacks_ = null;\n\n    /** @private {PromiseState} */\n    this.state_ = PromiseState.PENDING;\n\n    /** @private {boolean} */\n    this.handled_ = false;\n\n    /** @private {*} */\n    this.value_ = undefined;\n\n    /** @private {TaskQueue} */\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function(value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n  static resolve(opt_value) {\n    if (opt_value instanceof ManagedPromise) {\n      return opt_value;\n    }\n    return new ManagedPromise(resolve => resolve(opt_value));\n  }\n\n  /**\n   * Creates a promise that is immediately rejected with the given reason.\n   *\n   * @param {*=} opt_reason The rejection reason.\n   * @return {!ManagedPromise<?>} A new rejected promise.\n   */\n  static reject(opt_reason) {\n    return new ManagedPromise((_, reject) => reject(opt_reason));\n  }\n\n  /** @override */\n  toString() {\n    return 'ManagedPromise::' + getUid(this) +\n      ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n  }\n\n  /**\n   * Resolves this promise. If the new value is itself a promise, this function\n   * will wait for it to be resolved before notifying the registered listeners.\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @throws {TypeError} If {@code newValue === this}.\n   * @private\n   */\n  resolve_(newState, newValue) {\n    if (PromiseState.PENDING !== this.state_) {\n      return;\n    }\n\n    if (newValue === this) {\n      // See promise a+, 2.3.1\n      // http://promises-aplus.github.io/promises-spec/#point-48\n      newValue = new TypeError('A promise may not resolve to itself');\n      newState = PromiseState.REJECTED;\n    }\n\n    this.parent_ = null;\n    this.state_ = PromiseState.BLOCKED;\n\n    if (newState !== PromiseState.REJECTED) {\n      if (Thenable.isImplementation(newValue)) {\n        // 2.3.2\n        newValue = /** @type {!Thenable} */(newValue);\n        this.parent_ = newValue;\n        newValue.then(\n            this.unblockAndResolve_.bind(this, PromiseState.FULFILLED),\n            this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n        return;\n\n      } else if (newValue\n          && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        // 2.3.3\n\n        try {\n          // 2.3.3.1\n          var then = newValue['then'];\n        } catch (e) {\n          // 2.3.3.2\n          this.state_ = PromiseState.REJECTED;\n          this.value_ = e;\n          this.scheduleNotifications_();\n          return;\n        }\n\n        if (typeof then === 'function') {\n          // 2.3.3.3\n          this.invokeThen_(/** @type {!Object} */(newValue), then);\n          return;\n        }\n      }\n    }\n\n    if (newState === PromiseState.REJECTED &&\n        isError(newValue) && newValue.stack && this.stack_) {\n      newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n    }\n\n    // 2.3.3.4 and 2.3.4\n    this.state_ = newState;\n    this.value_ = newValue;\n    this.scheduleNotifications_();\n  }\n\n  /**\n   * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n   * A+ spec.\n   * @param {!Object} x The thenable object.\n   * @param {!Function} then The \"then\" function to invoke.\n   * @private\n   */\n  invokeThen_(x, then) {\n    var called = false;\n    var self = this;\n\n    var resolvePromise = function(value) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.1\n        self.unblockAndResolve_(PromiseState.FULFILLED, value);\n      }\n    };\n\n    var rejectPromise = function(reason) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.2\n        self.unblockAndResolve_(PromiseState.REJECTED, reason);\n      }\n    };\n\n    try {\n      // 2.3.3.3\n      then.call(x, resolvePromise, rejectPromise);\n    } catch (e) {\n      // 2.3.3.3.4.2\n      rejectPromise(e);\n    }\n  }\n\n  /**\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @private\n   */\n  unblockAndResolve_(newState, newValue) {\n    if (this.state_ === PromiseState.BLOCKED) {\n      this.state_ = PromiseState.PENDING;\n      this.resolve_(newState, newValue);\n    }\n  }\n\n  /**\n   * @private\n   */\n  scheduleNotifications_() {\n    vlog(2, () => this + ' scheduling notifications', this);\n\n    ON_CANCEL_HANDLER.delete(this);\n    if (this.value_ instanceof CancellationError\n        && this.value_.silent_) {\n      this.callbacks_ = null;\n    }\n\n    if (!this.queue_) {\n      this.queue_ = this.flow_.getActiveQueue_();\n    }\n\n    if (!this.handled_ &&\n        this.state_ === PromiseState.REJECTED &&\n        !(this.value_ instanceof CancellationError)) {\n      this.queue_.addUnhandledRejection(this);\n    }\n    this.queue_.scheduleCallbacks(this);\n  }\n\n  /** @override */\n  cancel(opt_reason) {\n    if (!canCancel(this)) {\n      return;\n    }\n\n    if (this.parent_ && canCancel(this.parent_)) {\n      /** @type {!CancellableThenable} */(this.parent_).cancel(opt_reason);\n    } else {\n      var reason = CancellationError.wrap(opt_reason);\n      let onCancel = ON_CANCEL_HANDLER.get(this);\n      if (onCancel) {\n        onCancel(reason);\n        ON_CANCEL_HANDLER.delete(this);\n      }\n\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.unblockAndResolve_(PromiseState.REJECTED, reason);\n      } else {\n        this.resolve_(PromiseState.REJECTED, reason);\n      }\n    }\n\n    function canCancel(promise) {\n      if (!(promise instanceof ManagedPromise)) {\n        return CancellableThenable.isImplementation(promise);\n      }\n      return promise.state_ === PromiseState.PENDING\n          || promise.state_ === PromiseState.BLOCKED;\n    }\n  }\n\n  /** @override */\n  then(opt_callback, opt_errback) {\n    return this.addCallback_(\n        opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n  }\n\n  /** @override */\n  catch(errback) {\n    return this.addCallback_(\n        null, errback, 'catch', ManagedPromise.prototype.catch);\n  }\n\n  /**\n   * @param {function(): (R|IThenable<R>)} callback\n   * @return {!ManagedPromise<R>}\n   * @template R\n   * @see ./promise.finally()\n   */\n  finally(callback) {\n    let result = thenFinally(this, callback);\n    return /** @type {!ManagedPromise} */(result);\n  }\n\n  /**\n   * Registers a new callback with this promise\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @param {string} name The callback name.\n   * @param {!Function} fn The function to use as the top of the stack when\n   *     recording the callback's creation point.\n   * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n   *     result of the invoked callback.\n   * @template R\n   * @private\n   */\n  addCallback_(callback, errback, name, fn) {\n    if (typeof callback !== 'function' && typeof errback !== 'function') {\n      return this;\n    }\n\n    this.handled_ = true;\n    if (this.queue_) {\n      this.queue_.clearUnhandledRejection(this);\n    }\n\n    var cb = new Task(\n        this.flow_,\n        this.invokeCallback_.bind(this, callback, errback),\n        name,\n        LONG_STACK_TRACES ? {name: 'Promise', top: fn} : undefined);\n    cb.promise.parent_ = this;\n\n    if (this.state_ !== PromiseState.PENDING &&\n        this.state_ !== PromiseState.BLOCKED) {\n      this.flow_.getActiveQueue_().enqueue(cb);\n    } else {\n      if (!this.callbacks_) {\n        this.callbacks_ = [];\n      }\n      this.callbacks_.push(cb);\n      cb.blocked = true;\n      this.flow_.getActiveQueue_().enqueue(cb);\n    }\n\n    return cb.promise;\n  }\n\n  /**\n   * Invokes a callback function attached to this promise.\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @template R\n   * @private\n   */\n  invokeCallback_(callback, errback) {\n    var callbackFn = callback;\n    if (this.state_ === PromiseState.REJECTED) {\n      callbackFn = errback;\n    }\n\n    if (typeof callbackFn === 'function') {\n      if (isGenerator(callbackFn)) {\n        return consume(callbackFn, null, this.value_);\n      }\n      return callbackFn(this.value_);\n    } else if (this.state_ === PromiseState.REJECTED) {\n      throw this.value_;\n    } else {\n      return this.value_;\n    }\n  }\n}\nCancellableThenable.addImplementation(ManagedPromise);\n\n\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n\n\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\nfunction Resolver() {}\n\n\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\nResolver.prototype.promise;\n\n\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\nResolver.prototype.resolve;\n\n\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\nResolver.prototype.reject;\n\n\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\nclass Deferred {\n  /**\n   * @param {ControlFlow=} opt_flow The control flow this instance was\n   *     created under. This should only be provided during unit tests.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(opt_flow, opt_skipLog) {\n    var fulfill, reject;\n\n    /** @type {!ManagedPromise<T>} */\n    this.promise = new ManagedPromise(function(f, r) {\n      fulfill = f;\n      reject = r;\n    }, opt_flow, opt_skipLog);\n\n    var self = this;\n    var checkNotSelf = function(value) {\n      if (value === self) {\n        throw new TypeError('May not resolve a Deferred with itself');\n      }\n    };\n\n    /**\n     * Resolves this deferred with the given value. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n     * @const\n     */\n    this.resolve = function(opt_value) {\n      checkNotSelf(opt_value);\n      fulfill(opt_value);\n    };\n\n    /**\n     * An alias for {@link #resolve}.\n     * @const\n     */\n    this.fulfill = this.resolve;\n\n    /**\n     * Rejects this promise with the given reason. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {*=} opt_reason The rejection reason.\n     * @const\n     */\n    this.reject = function(opt_reason) {\n      checkNotSelf(opt_reason);\n      reject(opt_reason);\n    };\n  }\n}\n\n\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\nfunction isError(value) {\n  return value instanceof Error ||\n      (!!value && typeof value === 'object'\n          && typeof value.message === 'string');\n}\n\n\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\nfunction delayed(ms) {\n  return createPromise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n  let resolve, reject;\n  let promise = new NativePromise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {promise, resolve, reject};\n}\n\n\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\nfunction fulfilled(opt_value) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  if (opt_value instanceof ctor) {\n    return /** @type {!Thenable} */(opt_value);\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        resolve => resolve(opt_value), undefined, SKIP_LOG);\n  }\n  return NativePromise.resolve(opt_value);\n}\n\n\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        (_, reject) => reject(opt_reason), undefined, SKIP_LOG);\n  }\n  return NativePromise.reject(opt_reason);\n}\n\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn, var_args) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function(fulfill, reject) {\n    try {\n      args.push(function(error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nfunction thenFinally(promise, callback) {\n  let error;\n  let mustThrow = false;\n  return promise.then(function() {\n    return callback();\n  }, function(err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function() {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n\n\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n\n\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n\n  } else if (callback) {\n    callback(value);\n  }\n}\n\n\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\nfunction all(arr) {\n  return createPromise(function(fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n    var onFulfilled = function(index, value) {\n      values[index] = value;\n      toFulfill--;\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function(value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction map(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          asap(\n              fn.call(opt_self, arr[i], i, /** @type {!Array} */(arr)),\n              function(value) {\n                values[i] = value;\n                processNext(i + 1);\n              },\n              reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction filter(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i, /** @type {!Array} */(arr));\n          asap(include, function(include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n            processNext(i + 1);\n            }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n  return fullyResolveValue(value);\n}\n\n\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(/** @type {!Array} */ (value));\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return /** @type {!ManagedPromise} */ (value);\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  return createPromise(resolve => resolve(value));\n}\n\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : (function() {\n    let n = 0;\n    for (let key in obj) {\n      n += 1;\n    }\n    return n;\n  })();\n\n  if (!numKeys) {\n    return createPromise(resolve => resolve(obj));\n  }\n\n  function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function(fulfill, reject) {\n    var forEachKey = isArray ? forEachElement: forEachProperty;\n\n    forEachKey(obj, function(partialValue, key) {\n      if (!Array.isArray(partialValue)\n          && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(\n          function(resolvedValue) {\n            obj[key] = resolvedValue;\n            maybeResolveValue();\n          },\n          reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\nclass Scheduler {\n  /**\n   * Schedules a task for execution. If the task function is a generator, the\n   * task will be executed using {@link ./promise.consume consume()}.\n   *\n   * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n   *     task.\n   * @param {string=} opt_description A description of the task for debugging\n   *     purposes.\n   * @return {!Thenable<T>} A promise that will be resolved with the task\n   *     result.\n   * @template T\n   */\n  execute(fn, opt_description) {}\n\n  /**\n   * Creates a new promise using the given resolver function.\n   *\n   * @param {function(\n   *             function((T|IThenable<T>|Thenable|null)=),\n   *             function(*=))} resolver\n   * @return {!Thenable<T>}\n   * @template T\n   */\n  promise(resolver) {}\n\n  /**\n   * Schedules a `setTimeout` call.\n   *\n   * @param {number} ms The timeout delay, in milliseconds.\n   * @param {string=} opt_description A description to accompany the timeout.\n   * @return {!Thenable<void>} A promise that will be resolved when the timeout\n   *     fires.\n   */\n  timeout(ms, opt_description) {}\n\n  /**\n   * Schedules a task to wait for a condition to hold.\n   *\n   * If the condition is defined as a function, it may return any value. Promise\n   * will be resolved before testing if the condition holds (resolution time\n   * counts towards the timeout). Once resolved, values are always evaluated as\n   * booleans.\n   *\n   * If the condition function throws, or returns a rejected promise, the\n   * wait task will fail.\n   *\n   * If the condition is defined as a promise, the scheduler will wait for it to\n   * settle. If the timeout expires before the promise settles, the promise\n   * returned by this function will be rejected.\n   *\n   * If this function is invoked with `timeout === 0`, or the timeout is\n   * omitted, this scheduler will wait indefinitely for the condition to be\n   * satisfied.\n   *\n   * @param {(!IThenable<T>|function())} condition The condition to poll,\n   *     or a promise to wait on.\n   * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n   *     condition to hold before timing out. If omitted, the flow will wait\n   *     indefinitely.\n   * @param {string=} opt_message An optional error message to include if the\n   *     wait times out; defaults to the empty string.\n   * @return {!Thenable<T>} A promise that will be fulfilled\n   *     when the condition has been satisfied. The promise shall be rejected\n   *     if the wait times out waiting for the condition.\n   * @throws {TypeError} If condition is not a function or promise or if timeout\n   *     is not a number >= 0.\n   * @template T\n   */\n  wait(condition, opt_timeout, opt_message) {}\n}\n\n\nlet USE_PROMISE_MANAGER;\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined\n      || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n\n\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\nfunction createPromise(resolver) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n\n\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  let timeout = opt_timeout || 0;\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function() {\n      if (!timeout) {\n        return condition;\n      }\n      return scheduler.promise(function(fulfill, reject) {\n        let start = Date.now();\n        let timer = setTimeout(function() {\n          timer = null;\n          reject(\n              new error.TimeoutError(\n                  (opt_message ? opt_message + '\\n' : '')\n                      + 'Timed out waiting for promise to resolve after '\n                      + (Date.now() - start) + 'ms'));\n        }, timeout);\n\n        /** @type {Thenable} */(condition).then(\n          function(value) {\n            timer && clearTimeout(timer);\n            fulfill(value);\n          },\n          function(error) {\n            timer && clearTimeout(timer);\n            reject(error);\n          });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' +\n        typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    let original = condition;\n    condition = () => consume(original);\n  }\n\n  return scheduler.execute(function() {\n    var startTime = Date.now();\n    return scheduler.promise(function(fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn = /** @type {function()} */(condition);\n        scheduler.execute(conditionFn).then(function(value) {\n          var elapsed = Date.now() - startTime;\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(\n                new error.TimeoutError(\n                    (opt_message ? opt_message + '\\n' : '')\n                        + `Wait timed out after ${elapsed}ms`));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n\n\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\nclass SimpleScheduler extends events.EventEmitter {\n  /** @override */\n  execute(fn) {\n    return this.promise((resolve, reject) => {\n      try {\n        if (isGenerator(fn)) {\n          consume(fn).then(resolve, reject);\n        } else {\n          resolve(fn.call(undefined));\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    });\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new NativePromise(resolver);\n  }\n\n  /** @override */\n  timeout(ms) {\n    return this.promise(resolve => setTimeout(_ => resolve(), ms));\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n}\nconst SIMPLE_SCHEDULER = new SimpleScheduler;\n\n\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\nclass ControlFlow extends events.EventEmitter {\n  constructor() {\n    if (!usePromiseManager()) {\n      throw TypeError(\n          'Cannot instantiate control flow when the promise manager has'\n              + ' been disabled');\n    }\n\n    super();\n\n    /** @private {boolean} */\n    this.propagateUnhandledRejections_ = true;\n\n    /** @private {TaskQueue} */\n    this.activeQueue_ = null;\n\n    /** @private {Set<TaskQueue>} */\n    this.taskQueues_ = null;\n\n    /**\n     * Microtask that controls shutting down the control flow. Upon shut down,\n     * the flow will emit an\n     * {@link ControlFlow.EventType.IDLE} event. Idle events\n     * always follow a brief timeout in order to catch latent errors from the\n     * last completed task. If this task had a callback registered, but no\n     * errback, and the task fails, the unhandled failure would not be reported\n     * by the promise system until the next turn of the event loop:\n     *\n     *   // Schedule 1 task that fails.\n     *   var result = promise.controlFlow().execute(\n     *       () => promise.rejected('failed'), 'example');\n     *   // Set a callback on the result. This delays reporting the unhandled\n     *   // failure for 1 turn of the event loop.\n     *   result.then(function() {});\n     *\n     * @private {MicroTask}\n     */\n    this.shutdownTask_ = null;\n\n    /**\n     * ID for a long running interval used to keep a Node.js process running\n     * while a control flow's event loop is still working. This is a cheap hack\n     * required since JS events are only scheduled to run when there is\n     * _actually_ something to run. When a control flow is waiting on a task,\n     * there will be nothing in the JS event loop and the process would\n     * terminate without this.\n     * @private\n     */\n    this.hold_ = null;\n  }\n\n  /**\n   * Returns a string representation of this control flow, which is its current\n   * {@linkplain #getSchedule() schedule}, sans task stack traces.\n   * @return {string} The string representation of this control flow.\n   * @override\n   */\n  toString() {\n    return this.getSchedule();\n  }\n\n  /**\n   * Sets whether any unhandled rejections should propagate up through the\n   * control flow stack and cause rejections within parent tasks. If error\n   * propagation is disabled, tasks will not be aborted when an unhandled\n   * promise rejection is detected, but the rejection _will_ trigger an\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * The default behavior is to propagate all unhandled rejections. _The use\n   * of this option is highly discouraged._\n   *\n   * @param {boolean} propagate whether to propagate errors.\n   */\n  setPropagateUnhandledRejections(propagate) {\n    this.propagateUnhandledRejections_ = propagate;\n  }\n\n  /**\n   * @return {boolean} Whether this flow is currently idle.\n   */\n  isIdle() {\n    return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n  }\n\n  /**\n   * Resets this instance, clearing its queue and removing all event listeners.\n   */\n  reset() {\n    this.cancelQueues_(new FlowResetError);\n    this.emit(ControlFlow.EventType.RESET);\n    this.removeAllListeners();\n    this.cancelShutdown_();\n  }\n\n  /**\n   * Generates an annotated string describing the internal state of this control\n   * flow, including the currently executing as well as pending tasks. If\n   * {@code opt_includeStackTraces === true}, the string will include the\n   * stack trace from when each task was scheduled.\n   * @param {string=} opt_includeStackTraces Whether to include the stack traces\n   * from when each task was scheduled. Defaults to false.\n   * @return {string} String representation of this flow's internal state.\n   */\n  getSchedule(opt_includeStackTraces) {\n    var ret = 'ControlFlow::' + getUid(this);\n    var activeQueue = this.activeQueue_;\n    if (!this.taskQueues_ || !this.taskQueues_.size) {\n      return ret;\n    }\n    var childIndent = '| ';\n    for (var q of this.taskQueues_) {\n      ret += '\\n' + printQ(q, childIndent);\n    }\n    return ret;\n\n    function printQ(q, indent) {\n      var ret = q.toString();\n      if (q === activeQueue) {\n        ret = '(active) ' + ret;\n      }\n      var prefix = indent + childIndent;\n      if (q.pending_) {\n        if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n          ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n          ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n        } else {\n          ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n        }\n      }\n      if (q.interrupts_) {\n        q.interrupts_.forEach((task) => {\n          ret += '\\n' + prefix + task;\n        });\n      }\n      if (q.tasks_) {\n        q.tasks_.forEach((task) => ret += printTask(task, '\\n' + prefix));\n      }\n      return indent + ret;\n    }\n\n    function printTask(task, prefix) {\n      var ret = prefix + task;\n      if (opt_includeStackTraces && task.promise.stack_) {\n        ret += prefix + childIndent\n            + (task.promise.stack_.stack || task.promise.stack_)\n                  .replace(/\\n/g, prefix);\n      }\n      return ret;\n    }\n  }\n\n  /**\n   * Returns the currently active task queue for this flow. If there is no\n   * active queue, one will be created.\n   * @return {!TaskQueue} the currently active task queue for this flow.\n   * @private\n   */\n  getActiveQueue_() {\n    if (this.activeQueue_) {\n      return this.activeQueue_;\n    }\n\n    this.activeQueue_ = new TaskQueue(this);\n    if (!this.taskQueues_) {\n      this.taskQueues_ = new Set();\n    }\n    this.taskQueues_.add(this.activeQueue_);\n    this.activeQueue_\n        .once('end', this.onQueueEnd_, this)\n        .once('error', this.onQueueError_, this);\n\n    asyncRun(() => this.activeQueue_ = null);\n    this.activeQueue_.start();\n    return this.activeQueue_;\n  }\n\n  /** @override */\n  execute(fn, opt_description) {\n    if (isGenerator(fn)) {\n      let original = fn;\n      fn = () => consume(original);\n    }\n\n    if (!this.hold_) {\n      let holdIntervalMs = 2147483647;  // 2^31-1; max timer length for Node.js\n      this.hold_ = setInterval(function() {}, holdIntervalMs);\n    }\n\n    let task = new Task(\n        this, fn, opt_description || '<anonymous>',\n        {name: 'Task', top: ControlFlow.prototype.execute},\n        true);\n\n    let q = this.getActiveQueue_();\n\n    for (let i = q.tasks_.length; i > 0; i--) {\n      let previousTask = q.tasks_[i - 1];\n      if (previousTask.userTask_) {\n        FLOW_LOG.warning(() => {\n          return `Detected scheduling of an unchained task.\nWhen the promise manager is disabled, unchained tasks will not wait for\npreviously scheduled tasks to finish before starting to execute.\nNew task: ${task.promise.stack_.stack}\nPrevious task: ${previousTask.promise.stack_.stack}`.split(/\\n/).join('\\n    ');\n        });\n        break;\n      }\n    }\n\n    q.enqueue(task);\n    this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n    return task.promise;\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new ManagedPromise(resolver, this, SKIP_LOG);\n  }\n\n  /** @override */\n  timeout(ms, opt_description) {\n    return this.execute(() => {\n      return this.promise(resolve => setTimeout(() => resolve(), ms));\n    }, opt_description);\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n\n  /**\n   * Executes a function in the next available turn of the JavaScript event\n   * loop. This ensures the function runs with its own task queue and any\n   * scheduled tasks will run in \"parallel\" to those scheduled in the current\n   * function.\n   *\n   *     flow.execute(() => console.log('a'));\n   *     flow.execute(() => console.log('b'));\n   *     flow.execute(() => console.log('c'));\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('d'));\n   *        flow.execute(() => console.log('e'));\n   *     });\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('f'));\n   *        flow.execute(() => console.log('g'));\n   *     });\n   *     flow.once('idle', () => console.log('fin'));\n   *     // a\n   *     // d\n   *     // f\n   *     // b\n   *     // e\n   *     // g\n   *     // c\n   *     // fin\n   *\n   * If the function itself throws, the error will be treated the same as an\n   * unhandled rejection within the control flow.\n   *\n   * __NOTE__: This function is considered _unstable_.\n   *\n   * @param {!Function} fn The function to execute.\n   * @param {Object=} opt_self The object in whose context to run the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   */\n  async(fn, opt_self, var_args) {\n    asyncRun(() => {\n      // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n      this.activeQueue_ = null;\n      var q = this.getActiveQueue_();\n      try {\n        q.execute_(fn.bind(opt_self, var_args));\n      } catch (ex) {\n        var cancellationError = CancellationError.wrap(ex,\n            'Function passed to ControlFlow.async() threw');\n        cancellationError.silent_ = true;\n        q.abort_(cancellationError);\n      } finally {\n        this.activeQueue_ = null;\n      }\n    });\n  }\n\n  /**\n   * Event handler for when a task queue is exhausted. This starts the shutdown\n   * sequence for this instance if there are no remaining task queues: after\n   * one turn of the event loop, this object will emit the\n   * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n   * listeners that it has completed. During this wait, if another task is\n   * scheduled, the shutdown will be aborted.\n   *\n   * @param {!TaskQueue} q the completed task queue.\n   * @private\n   */\n  onQueueEnd_(q) {\n    if (!this.taskQueues_) {\n      return;\n    }\n    this.taskQueues_.delete(q);\n\n    vlog(1, () => q + ' has finished');\n    vlog(1, () => this.taskQueues_.size + ' queues remain\\n' + this, this);\n\n    if (!this.taskQueues_.size) {\n      if (this.shutdownTask_) {\n        throw Error('Already have a shutdown task??');\n      }\n      vlog(1, () => 'Scheduling shutdown\\n' + this);\n      this.shutdownTask_ = new MicroTask(() => this.shutdown_());\n    }\n  }\n\n  /**\n   * Event handler for when a task queue terminates with an error. This triggers\n   * the cancellation of all other task queues and a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   * If there are no error event listeners registered with this instance, the\n   * error will be rethrown to the global error handler.\n   *\n   * @param {*} error the error that caused the task queue to terminate.\n   * @param {!TaskQueue} q the task queue.\n   * @private\n   */\n  onQueueError_(error, q) {\n    if (this.taskQueues_) {\n      this.taskQueues_.delete(q);\n    }\n    this.cancelQueues_(CancellationError.wrap(\n        error, 'There was an uncaught error in the control flow'));\n    this.cancelShutdown_();\n    this.cancelHold_();\n\n    setTimeout(() => {\n      let listeners = this.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n      if (!listeners.size) {\n        throw error;\n      } else {\n        this.reportUncaughtException_(error);\n      }\n    }, 0);\n  }\n\n  /**\n   * Cancels all remaining task queues.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  cancelQueues_(reason) {\n    reason.silent_ = true;\n    if (this.taskQueues_) {\n      for (var q of this.taskQueues_) {\n        q.removeAllListeners();\n        q.abort_(reason);\n      }\n      this.taskQueues_.clear();\n      this.taskQueues_ = null;\n    }\n  }\n\n  /**\n   * Reports an uncaught exception using a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * @param {*} e the error to report.\n   * @private\n   */\n  reportUncaughtException_(e) {\n    this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n  }\n\n  /** @private */\n  cancelHold_() {\n    if (this.hold_) {\n      clearInterval(this.hold_);\n      this.hold_ = null;\n    }\n  }\n\n  /** @private */\n  shutdown_() {\n    vlog(1, () => 'Going idle: ' + this);\n    this.cancelHold_();\n    this.shutdownTask_ = null;\n    this.emit(ControlFlow.EventType.IDLE);\n  }\n\n  /**\n   * Cancels the shutdown sequence if it is currently scheduled.\n   * @private\n   */\n  cancelShutdown_() {\n    if (this.shutdownTask_) {\n      this.shutdownTask_.cancel();\n      this.shutdownTask_ = null;\n    }\n  }\n}\n\n\n/**\n * Events that may be emitted by an {@link ControlFlow}.\n * @enum {string}\n */\nControlFlow.EventType = {\n\n  /** Emitted when all tasks have been successfully executed. */\n  IDLE: 'idle',\n\n  /** Emitted when a ControlFlow has been reset. */\n  RESET: 'reset',\n\n  /** Emitted whenever a new task has been scheduled. */\n  SCHEDULE_TASK: 'scheduleTask',\n\n  /**\n   * Emitted whenever a control flow aborts due to an unhandled promise\n   * rejection. This event will be emitted along with the offending rejection\n   * reason. Upon emitting this event, the control flow will empty its task\n   * queue and revert to its initial state.\n   */\n  UNCAUGHT_EXCEPTION: 'uncaughtException'\n};\n\n\n/**\n * Wraps a function to execute as a cancellable micro task.\n * @final\n */\nclass MicroTask {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  constructor(fn) {\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(() => {\n      if (!this.cancelled_) {\n        fn();\n      }\n    });\n  }\n\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n  static run(fn) {\n    NativePromise.resolve().then(function() {\n      try {\n        fn();\n      } catch (ignored) {\n        // Do nothing.\n      }\n    });\n  }\n\n  /**\n   * Cancels the execution of this task. Note: this will not prevent the task\n   * timer from firing, just the invocation of the wrapped function.\n   */\n  cancel() {\n    this.cancelled_ = true;\n  }\n}\n\n\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\nclass Task extends Deferred {\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  constructor(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    super(flow, SKIP_LOG);\n    getUid(this);\n\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n    this.execute = fn;\n\n    /** @type {string} */\n    this.description = description;\n\n    /** @type {TaskQueue} */\n    this.queue = null;\n\n    /** @private @const {boolean} */\n    this.userTask_ = !!opt_isUserTask;\n\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n    this.blocked = false;\n\n    if (opt_stackOptions) {\n      this.promise.stack_ = captureStackTrace(\n          opt_stackOptions.name, this.description, opt_stackOptions.top);\n    }\n  }\n\n  /** @override */\n  toString() {\n    return 'Task::' + getUid(this) + '<' + this.description + '>';\n  }\n}\n\n\n/** @enum {string} */\nconst TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n\n\n/**\n * @final\n */\nclass TaskQueue extends events.EventEmitter {\n  /** @param {!ControlFlow} flow . */\n  constructor(flow) {\n    super();\n\n    /** @private {string} */\n    this.name_ = 'TaskQueue::' + getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = flow;\n\n    /** @private {!Array<!Task>} */\n    this.tasks_ = [];\n\n    /** @private {Array<!Task>} */\n    this.interrupts_ = null;\n\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n    this.pending_ = null;\n\n    /** @private {TaskQueue} */\n    this.subQ_ = null;\n\n    /** @private {TaskQueueState} */\n    this.state_ = TaskQueueState.NEW;\n\n    /** @private {!Set<!ManagedPromise>} */\n    this.unhandledRejections_ = new Set();\n  }\n\n  /** @override */\n  toString() {\n    return 'TaskQueue::' + getUid(this);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  addUnhandledRejection(promise) {\n    // TODO: node 4.0.0+\n    vlog(2, () => this + ' registering unhandled rejection: ' + promise, this);\n    this.unhandledRejections_.add(promise);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  clearUnhandledRejection(promise) {\n    var deleted = this.unhandledRejections_.delete(promise);\n    if (deleted) {\n      // TODO: node 4.0.0+\n      vlog(2, () => this + ' clearing unhandled rejection: ' + promise, this);\n    }\n  }\n\n  /**\n   * Enqueues a new task for execution.\n   * @param {!Task} task The task to enqueue.\n   * @throws {Error} If this instance has already started execution.\n   */\n  enqueue(task) {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw Error('TaskQueue has started: ' + this);\n    }\n\n    if (task.queue) {\n      throw Error('Task is already scheduled in another queue');\n    }\n\n    this.tasks_.push(task);\n    task.queue = this;\n    ON_CANCEL_HANDLER.set(\n        task.promise,\n        (e) => this.onTaskCancelled_(task, e));\n\n    vlog(1, () => this + '.enqueue(' + task + ')', this);\n    vlog(2, () => this.flow_.toString(), this);\n  }\n\n  /**\n   * Schedules the callbacks registered on the given promise in this queue.\n   *\n   * @param {!ManagedPromise} promise the promise whose callbacks should be\n   *     registered as interrupts in this task queue.\n   * @throws {Error} if this queue has already finished.\n   */\n  scheduleCallbacks(promise) {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      throw new Error('cannot interrupt a finished q(' + this + ')');\n    }\n\n    if (this.pending_ && this.pending_.task.promise === promise) {\n      this.pending_.task.promise.queue_ = null;\n      this.pending_ = null;\n      asyncRun(() => this.executeNext_());\n    }\n\n    if (!promise.callbacks_) {\n      return;\n    }\n    promise.callbacks_.forEach(function(cb) {\n      cb.blocked = false;\n      if (cb.queue) {\n        return;\n      }\n\n      ON_CANCEL_HANDLER.set(\n          cb.promise,\n          (e) => this.onTaskCancelled_(cb, e));\n\n      if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n        return;\n      }\n\n      if (cb.queue) {\n        cb.queue.dropTask_(cb);\n      }\n\n      cb.queue = this;\n      if (!this.interrupts_) {\n        this.interrupts_ = [];\n      }\n      this.interrupts_.push(cb);\n    }, this);\n    promise.callbacks_ = null;\n    vlog(2, () => this + ' interrupted\\n' + this.flow_, this);\n  }\n\n  /**\n   * Starts executing tasks in this queue. Once called, no further tasks may\n   * be {@linkplain #enqueue() enqueued} with this instance.\n   *\n   * @throws {Error} if this queue has already been started.\n   */\n  start() {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw new Error('TaskQueue has already started');\n    }\n    // Always asynchronously execute next, even if there doesn't look like\n    // there is anything in the queue. This will catch pending unhandled\n    // rejections that were registered before start was called.\n    asyncRun(() => this.executeNext_());\n  }\n\n  /**\n   * Aborts this task queue. If there are any scheduled tasks, they are silently\n   * cancelled and discarded (their callbacks will never fire). If this queue\n   * has a _pending_ task, the abortion error is used to cancel that task.\n   * Otherwise, this queue will emit an error event.\n   *\n   * @param {*} error The abortion reason.\n   * @private\n   */\n  abort_(error) {\n    var cancellation;\n\n    if (error instanceof FlowResetError) {\n      cancellation = error;\n    } else {\n      cancellation = new DiscardedTaskError(error);\n    }\n\n    if (this.interrupts_ && this.interrupts_.length) {\n      this.interrupts_.forEach((t) => t.reject(cancellation));\n      this.interrupts_ = [];\n    }\n\n    if (this.tasks_ && this.tasks_.length) {\n      this.tasks_.forEach((t) => t.reject(cancellation));\n      this.tasks_ = [];\n    }\n\n    // Now that all of the remaining tasks have been silently cancelled (e.g. no\n    // existing callbacks on those tasks will fire), clear the silence bit on\n    // the cancellation error. This ensures additional callbacks registered in\n    // the future will actually execute.\n    cancellation.silent_ = false;\n\n    if (this.pending_) {\n      vlog(2, () => this + '.abort(); cancelling pending task', this);\n      this.pending_.task.promise.cancel(\n          /** @type {!CancellationError} */(error));\n\n    } else {\n      vlog(2, () => this + '.abort(); emitting error event', this);\n      this.emit('error', error, this);\n    }\n  }\n\n  /** @private */\n  executeNext_() {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      return;\n    }\n    this.state_ = TaskQueueState.STARTED;\n\n    if (this.pending_ !== null || this.processUnhandledRejections_()) {\n      return;\n    }\n\n    var task;\n    do {\n      task = this.getNextTask_();\n    } while (task && !isPending(task.promise));\n\n    if (!task) {\n      this.state_ = TaskQueueState.FINISHED;\n      this.tasks_ = [];\n      this.interrupts_ = null;\n      vlog(2, () => this + '.emit(end)', this);\n      this.emit('end', this);\n      return;\n    }\n\n    let result = undefined;\n    this.subQ_ = new TaskQueue(this.flow_);\n\n    this.subQ_.once('end', () => {  // On task completion.\n      this.subQ_ = null;\n      this.pending_ && this.pending_.task.resolve(result);\n    });\n\n    this.subQ_.once('error', e => {  // On task failure.\n      this.subQ_ = null;\n      if (Thenable.isImplementation(result)) {\n        result.cancel(CancellationError.wrap(e));\n      }\n      this.pending_ && this.pending_.task.reject(e);\n    });\n    vlog(2, () => `${this} created ${this.subQ_} for ${task}`);\n\n    try {\n      this.pending_ = {task: task, q: this.subQ_};\n      task.promise.queue_ = this;\n      result = this.subQ_.execute_(task.execute);\n      this.subQ_.start();\n    } catch (ex) {\n      this.subQ_.abort_(ex);\n    }\n  }\n\n  /**\n   * @param {!Function} fn .\n   * @return {T} .\n   * @template T\n   * @private\n   */\n  execute_(fn) {\n    try {\n      activeFlows.push(this.flow_);\n      this.flow_.activeQueue_ = this;\n      return fn();\n    } finally {\n      this.flow_.activeQueue_ = null;\n      activeFlows.pop();\n    }\n  }\n\n  /**\n   * Process any unhandled rejections registered with this task queue. If there\n   * is a rejection, this queue will be aborted with the rejection error. If\n   * there are multiple rejections registered, this queue will be aborted with\n   * a {@link MultipleUnhandledRejectionError}.\n   * @return {boolean} whether there was an unhandled rejection.\n   * @private\n   */\n  processUnhandledRejections_() {\n    if (!this.unhandledRejections_.size) {\n      return false;\n    }\n\n    var errors = new Set();\n    for (var rejection of this.unhandledRejections_) {\n      errors.add(rejection.value_);\n    }\n    this.unhandledRejections_.clear();\n\n    var errorToReport = errors.size === 1\n        ? errors.values().next().value\n        : new MultipleUnhandledRejectionError(errors);\n\n    vlog(1, () => this + ' aborting due to unhandled rejections', this);\n    if (this.flow_.propagateUnhandledRejections_) {\n      this.abort_(errorToReport);\n      return true;\n    } else {\n      vlog(1, 'error propagation disabled; reporting to control flow');\n      this.flow_.reportUncaughtException_(errorToReport);\n      return false;\n    }\n  }\n\n  /**\n   * @param {!Task} task The task to drop.\n   * @private\n   */\n  dropTask_(task) {\n    var index;\n    if (this.interrupts_) {\n      index = this.interrupts_.indexOf(task);\n      if (index != -1) {\n        task.queue = null;\n        this.interrupts_.splice(index, 1);\n        return;\n      }\n    }\n\n    index = this.tasks_.indexOf(task);\n    if (index != -1) {\n      task.queue = null;\n      this.tasks_.splice(index, 1);\n    }\n  }\n\n  /**\n   * @param {!Task} task The task that was cancelled.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  onTaskCancelled_(task, reason) {\n    if (this.pending_ && this.pending_.task === task) {\n      this.pending_.q.abort_(reason);\n    } else {\n      this.dropTask_(task);\n    }\n  }\n\n  /**\n   * @return {(Task|undefined)} the next task scheduled within this queue,\n   *     if any.\n   * @private\n   */\n  getNextTask_() {\n    var task = undefined;\n    while (true) {\n      if (this.interrupts_) {\n        task = this.interrupts_.shift();\n      }\n      if (!task && this.tasks_) {\n        task = this.tasks_.shift();\n      }\n      if (task && task.blocked) {\n        vlog(2, () => this + ' skipping blocked task ' + task, this);\n        task.queue = null;\n        task = null;\n        // TODO: recurse when tail-call optimization is available in node.\n      } else {\n        break;\n      }\n    }\n    return task;\n  }\n}\n\n\n\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\nvar defaultFlow;\n\n\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\nvar activeFlows = [];\n\n\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error(\n        'You  may not change set the control flow when the promise'\n            +' manager is disabled');\n  }\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n  defaultFlow = flow;\n}\n\n\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow;\n  }\n  return defaultFlow;\n}\n\n\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\nfunction createFlow(callback) {\n  var flow = new ControlFlow;\n  return flow.execute(function() {\n    return callback(flow);\n  });\n}\n\n\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n\n\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\nfunction consume(generatorFn, opt_self, ...var_args) {\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' +\n        generatorFn.constructor.name);\n  }\n\n  let ret;\n  return ret = createPromise((resolve, reject) => {\n    let generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n\n    /** @param {*=} opt_value . */\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n\n    /** @param {*=} opt_error . */\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return;  // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() { return usePromiseManager(); },\n  set USE_PROMISE_MANAGER(/** boolean */value) { USE_PROMISE_MANAGER = value; },\n\n  get LONG_STACK_TRACES() { return LONG_STACK_TRACES; },\n  set LONG_STACK_TRACES(v) { LONG_STACK_TRACES = v; },\n};\n"]},"metadata":{},"sourceType":"script"}