{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    rimraf = require('rimraf'),\n    tmp = require('tmp');\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\n\n\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n} // PUBLIC API\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\n\n\nexports.rmDir = function (dirPath) {\n  return new Promise(function (fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function (err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\n\n\nexports.copy = function (src, dst) {\n  return new Promise(function (fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n    rs.pipe(ws);\n  });\n};\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\n\n\nexports.copyDir = function (src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function (p) {\n      return !opt_exclude.test(p);\n    };\n  } // TODO(jleyba): Make this function completely async.\n\n\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function (file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(\n    /** @type {function(string): boolean} */\n    predicate);\n  }\n\n  var results = [];\n  files.forEach(function (file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n  return Promise.all(results).then(() => dst);\n};\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\n\n\nexports.exists = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    let type = typeof aPath;\n\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\n\n\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\n\n\nexports.unlink = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    fs.exists(aPath, function (exists) {\n      if (exists) {\n        fs.unlink(aPath, function (err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpDir = function () {\n  return checkedCall(tmp.dir);\n};\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpFile = function (opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\n\n\nexports.findInPath = function (file, opt_checkCwd) {\n  let dirs = [];\n\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\n\n\nexports.read = function (aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\n\n\nexports.write = function (aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdir = function (aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir)).then(() => mkdirp(dir)).then(() => callback(null, dir), err => callback(err));\n\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\n\n\nexports.walkDir = function (rootPath) {\n  let seen = [];\n  return function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback)).then(files => Promise.all(files.map(file => {\n      file = path.join(dir, file);\n      return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n        seen.push({\n          path: path.relative(rootPath, file),\n          dir: stats.isDirectory()\n        });\n        return stats.isDirectory() && walk(file);\n      });\n    })));\n  }(rootPath).then(() => seen);\n};","map":{"version":3,"sources":["/Users/dariya/Documents/GitHub/Web-development/lab 4&5/wgg87w--run/node_modules/selenium-webdriver/io/index.js"],"names":["fs","require","path","rimraf","tmp","checkedCall","fn","Promise","resolve","reject","err","value","e","exports","rmDir","dirPath","fulfill","numAttempts","attemptRm","code","copy","src","dst","rs","createReadStream","on","ws","createWriteStream","pipe","copyDir","opt_exclude","predicate","p","test","existsSync","mkdirSync","files","readdirSync","map","file","join","filter","results","forEach","stats","statSync","target","basename","isDirectory","mode","push","all","then","exists","aPath","type","TypeError","stat","callback","unlink","tmpDir","dir","tmpFile","opt_options","findInPath","opt_checkCwd","dirs","process","cwd","apply","env","split","delimiter","foundInDir","find","isFile","ex","read","readFile","write","data","writeFile","mkdir","undefined","mkdirp","dirname","walkDir","rootPath","seen","walk","readdir","cb","relative"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    rimraf = require('rimraf'),\n    tmp = require('tmp');\n\n\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n\n\n// PUBLIC API\n\n\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\nexports.rmDir = function(dirPath) {\n  return new Promise(function(fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function(err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n\n\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\nexports.copy = function(src, dst) {\n  return new Promise(function(fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n\n    rs.pipe(ws);\n  });\n};\n\n\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\nexports.copyDir = function(src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function(p) {\n      return !opt_exclude.test(p);\n    };\n  }\n\n  // TODO(jleyba): Make this function completely async.\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function(file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(/** @type {function(string): boolean} */(predicate));\n  }\n\n  var results = [];\n  files.forEach(function(file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n\n  return Promise.all(results).then(() => dst);\n};\n\n\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\nexports.exists = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    let type = typeof aPath;\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n\n\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n\n\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\nexports.unlink = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    fs.exists(aPath, function(exists) {\n      if (exists) {\n        fs.unlink(aPath, function(err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n\n\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpDir = function() {\n  return checkedCall(tmp.dir);\n};\n\n\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpFile = function(opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n\n\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\nexports.findInPath = function(file, opt_checkCwd) {\n  let dirs = [];\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n\n\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\nexports.read = function(aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n\n\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\nexports.write = function(aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n\n\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdir = function(aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir))\n              .then(() => mkdirp(dir))\n              .then(() => callback(null, dir), err => callback(err));\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\nexports.walkDir = function(rootPath) {\n  let seen = [];\n  return (function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback))\n        .then(files => Promise.all(files.map(file => {\n          file = path.join(dir, file);\n          return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n            seen.push({\n              path: path.relative(rootPath, file),\n              dir: stats.isDirectory()\n            });\n            return stats.isDirectory() && walk(file);\n          });\n        })));\n  })(rootPath).then(() => seen);\n};\n"]},"metadata":{},"sourceType":"script"}