{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n'use strict';\n\nconst actions = require('./actions');\n\nconst by = require('./by');\n\nconst Capabilities = require('./capabilities').Capabilities;\n\nconst command = require('./command');\n\nconst error = require('./error');\n\nconst input = require('./input');\n\nconst logging = require('./logging');\n\nconst {\n  Session\n} = require('./session');\n\nconst Symbols = require('./symbols');\n\nconst promise = require('./promise');\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\n\n\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n    /** @type {function(!WebDriver): OUT} */\n\n    this.fn = fn;\n  }\n  /** @return {string} A description of this condition. */\n\n\n  description() {\n    return this.description_;\n  }\n\n}\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\n\n\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn);\n  }\n\n} //////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\n\n\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters);\n    return executor.execute(command);\n  });\n}\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\n\n\nfunction toWireValue(obj) {\n  if (promise.isPromise(obj)) {\n    return Promise.resolve(obj).then(toWireValue);\n  }\n\n  return Promise.resolve(convertValue(obj));\n}\n\nfunction convertValue(value) {\n  if (value === void 0 || value === null) {\n    return value;\n  }\n\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n\n  return convertKeys(value);\n}\n\nfunction convertKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  const ret = isArray ? new Array(numKeys) : {};\n\n  if (!numKeys) {\n    return Promise.resolve(ret);\n  }\n\n  let numResolved = 0;\n\n  function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        fn(obj[i], i);\n      }\n    } else {\n      for (let key in obj) {\n        fn(obj[key], key);\n      }\n    }\n  }\n\n  return new Promise(function (done, reject) {\n    forEachKey(obj, function (value, key) {\n      if (promise.isPromise(value)) {\n        value.then(toWireValue).then(setValue, reject);\n      } else {\n        value = convertValue(value);\n\n        if (promise.isPromise(value)) {\n          value.then(toWireValue).then(setValue, reject);\n        } else {\n          setValue(value);\n        }\n      }\n\n      function setValue(value) {\n        ret[key] = value;\n        maybeFulfill();\n      }\n    });\n\n    function maybeFulfill() {\n      if (++numResolved === numKeys) {\n        done(ret);\n      }\n    }\n  });\n}\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\n\n\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(v => fromWireValue(driver, v));\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (value && typeof value === 'object') {\n    let result = {};\n\n    for (let key in value) {\n      if (value.hasOwnProperty(key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n\n    value = result;\n  }\n\n  return value;\n}\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\n\n\nclass IWebDriver {\n  /** @return {!promise.ControlFlow} The control flow used by this instance. */\n  controlFlow() {}\n  /**\n   * Schedules a {@link command.Command} to be executed by this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @param {string} description A description of the command for debugging.\n   * @return {!promise.Thenable<T>} A promise that will be resolved\n   *     with the command result.\n   * @template T\n   */\n\n\n  schedule(command, description) {}\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or {@code null}.\n   */\n\n\n  setFileDetector(detector) {}\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n\n\n  getExecutor() {}\n  /**\n   * @return {!promise.Thenable<!Session>} A promise for this client's session.\n   */\n\n\n  getSession() {}\n  /**\n   * @return {!promise.Thenable<!Capabilities>} A promise that will resolve with\n   *     the this instance's capabilities.\n   */\n\n\n  getCapabilities() {}\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n\n\n  quit() {}\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * scheduled for execution until {@link actions.ActionSequence#perform} is\n   * called. Example:\n   *\n   *     driver.actions().\n   *         mouseDown(element1).\n   *         mouseMove(element2).\n   *         mouseUp().\n   *         perform();\n   *\n   * @return {!actions.ActionSequence} A new action sequence for this instance.\n   */\n\n\n  actions() {}\n  /**\n   * Creates a new touch sequence using this driver. The sequence will not be\n   * scheduled for execution until {@link actions.TouchSequence#perform} is\n   * called. Example:\n   *\n   *     driver.touchActions().\n   *         tap(element1).\n   *         doubleTap(element2).\n   *         perform();\n   *\n   * @return {!actions.TouchSequence} A new touch sequence for this instance.\n   */\n\n\n  touchActions() {}\n  /**\n   * Schedules a command to execute JavaScript in the context of the currently\n   * selected frame or window. The script fragment will be executed as the body\n   * of an anonymous function. If the script is provided as a function object,\n   * that function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the {@code arguments} object.\n   * Arguments may be a boolean, number, string, or {@linkplain WebElement}.\n   * Arrays and objects may also be used as script arguments as long as each item\n   * adheres to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * {@code document} may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {!promise.Thenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n\n\n  executeScript(script, var_args) {}\n  /**\n   * Schedules a command to execute asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the {@code arguments} object.\n   * Arguments may be a boolean, number, string, or {@code WebElement}.\n   * Arrays and objects may also be used as script arguments as long as each item\n   * adheres to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are finished\n   * by invoking the provided callback. This callback will always be injected\n   * into the executed function as the last argument, and thus may be referenced\n   * with {@code arguments[arguments.length - 1]}. The following steps will be\n   * taken for resolving this functions return value against the first argument\n   * to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a\n   *     {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so it\n   * should not reference any symbols not defined in the scope of the page under\n   * test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {!promise.Thenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n\n\n  executeAsyncScript(script, var_args) {}\n  /**\n   * Schedules a command to execute a custom function.\n   * @param {function(...): (T|IThenable<T>)} fn The function to execute.\n   * @param {Object=} opt_scope The object in whose scope to execute the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   * @return {!promise.Thenable<T>} A promise that will be resolved'\n   *     with the function's result.\n   * @template T\n   */\n\n\n  call(fn, opt_scope, var_args) {}\n  /**\n   * Schedules a command to wait for a condition to hold. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@link promise.Promise promise}, the polling\n   * loop will wait for it to be resolved and use the resolved value for whether\n   * the condition has been satisfied. Note the resolution time for a promise\n   * is factored into whether a wait has timed out.\n   *\n   * Note, if the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     var button = driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *     button.click();\n   *\n   * This function may also be used to block the command flow on the resolution\n   * of any thenable promise object. When given a promise, the command will\n   * simply wait for its resolution before completing. A timeout may be provided\n   * to fail the command if the promise does not resolve before the timeout\n   * expires.\n   *\n   * _Example:_ Suppose you have a function, `startTestServer`, that returns a\n   * promise for when a server is ready for requests. You can block a WebDriver\n   * client on this promise with:\n   *\n   *     var started = startTestServer();\n   *     driver.wait(started, 5 * 1000, 'Server should start within 5 seconds');\n   *     driver.get(getServerUrl());\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} opt_timeout How long to wait for the condition to be true.\n   * @param {string=} opt_message An optional message to use if the wait times\n   *     out.\n   * @return {!(promise.Thenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     input condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n\n\n  wait(condition, opt_timeout, opt_message) {}\n  /**\n   * Schedules a command to make the driver sleep for the given amount of time.\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the sleep has finished.\n   */\n\n\n  sleep(ms) {}\n  /**\n   * Schedules a command to retrieve the current window handle.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current window handle.\n   */\n\n\n  getWindowHandle() {}\n  /**\n   * Schedules a command to retrieve the current list of available window handles.\n   * @return {!promise.Thenable<!Array<string>>} A promise that will\n   *     be resolved with an array of window handles.\n   */\n\n\n  getAllWindowHandles() {}\n  /**\n   * Schedules a command to retrieve the current page's source. The page source\n   * returned is a representation of the underlying DOM: do not expect it to be\n   * formatted or escaped in the same way as the response sent from the web\n   * server.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current page source.\n   */\n\n\n  getPageSource() {}\n  /**\n   * Schedules a command to close the current window.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n\n\n  close() {}\n  /**\n   * Schedules a command to navigate to the given URL.\n   * @param {string} url The fully qualified URL to open.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the document has finished loading.\n   */\n\n\n  get(url) {}\n  /**\n   * Schedules a command to retrieve the URL of the current page.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current URL.\n   */\n\n\n  getCurrentUrl() {}\n  /**\n   * Schedules a command to retrieve the current page's title.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current page's title.\n   */\n\n\n  getTitle() {}\n  /**\n   * Schedule a command to find an element on the page. If the element cannot be\n   * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned\n   * by the driver. Unlike other commands, this error cannot be suppressed. In\n   * other words, scheduling a command to find an element doubles as an assert\n   * that the element is present on the page. To test whether an element is\n   * present on the page, use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n\n\n  findElement(locator) {}\n  /**\n   * Schedule a command to search for multiple elements on the page.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A\n   *     promise that will resolve to an array of WebElements.\n   */\n\n\n  findElements(locator) {}\n  /**\n   * Schedule a command to take a screenshot. The driver makes a best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n\n\n  takeScreenshot() {}\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n\n\n  manage() {}\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n\n\n  navigate() {}\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n\n\n  switchTo() {}\n\n}\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\n\n\nclass WebDriver {\n  /**\n   * @param {!(Session|IThenable<!Session>)} session Either a known session or a\n   *     promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {promise.ControlFlow=} opt_flow The flow to\n   *     schedule commands through. Defaults to the active flow object.\n   * @param {(function(this: void): ?)=} opt_onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, opt_flow, opt_onQuit) {\n    /** @private {!promise.ControlFlow} */\n    this.flow_ = opt_flow || promise.controlFlow();\n    /** @private {!promise.Thenable<!Session>} */\n\n    this.session_ = this.flow_.promise(resolve => resolve(session));\n    /** @private {!command.Executor} */\n\n    this.executor_ = executor;\n    /** @private {input.FileDetector} */\n\n    this.fileDetector_ = null;\n    /** @private @const {(function(this: void): ?|undefined)} */\n\n    this.onQuit_ = opt_onQuit;\n  }\n  /**\n   * Creates a new WebDriver client for an existing session.\n   * @param {!command.Executor} executor Command executor to use when querying\n   *     for session details.\n   * @param {string} sessionId ID of the session to attach to.\n   * @param {promise.ControlFlow=} opt_flow The control flow all\n   *     driver commands should execute under. Defaults to the\n   *     {@link promise.controlFlow() currently active}  control flow.\n   * @return {!WebDriver} A new client for the specified session.\n   */\n\n\n  static attachToSession(executor, sessionId, opt_flow) {\n    let flow = opt_flow || promise.controlFlow();\n    let cmd = new command.Command(command.Name.DESCRIBE_SESSION).setParameter('sessionId', sessionId);\n    let session = flow.execute(() => executeCommand(executor, cmd).catch(err => {\n      // The DESCRIBE_SESSION command is not supported by the W3C spec, so\n      // if we get back an unknown command, just return a session with\n      // unknown capabilities.\n      if (err instanceof error.UnknownCommandError) {\n        return new Session(sessionId, new Capabilities());\n      }\n\n      throw err;\n    }), 'WebDriver.attachToSession()');\n    return new WebDriver(session, executor, flow);\n  }\n  /**\n   * Creates a new WebDriver session.\n   *\n   * By default, the requested session `capabilities` are merely \"desired\" and\n   * the remote end will still create a new session even if it cannot satisfy\n   * all of the requested capabilities. You can query which capabilities a\n   * session actually has using the\n   * {@linkplain #getCapabilities() getCapabilities()} method on the returned\n   * WebDriver instance.\n   *\n   * To define _required capabilities_, provide the `capabilities` as an object\n   * literal with `required` and `desired` keys. The `desired` key may be\n   * omitted if all capabilities are required, and vice versa. If the server\n   * cannot create a session with all of the required capabilities, it will\n   * return an {@linkplain error.SessionNotCreatedError}.\n   *\n   *     let required = new Capabilities().set('browserName', 'firefox');\n   *     let desired = new Capabilities().set('version', '45');\n   *     let driver = WebDriver.createSession(executor, {required, desired});\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * It is recommended that this promise is left _unhandled_ so it will\n   * propagate through the {@linkplain promise.ControlFlow control flow} and\n   * cause subsequent commands to fail.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {(!Capabilities|\n   *          {desired: (Capabilities|undefined),\n   *           required: (Capabilities|undefined)})} capabilities The desired\n   *     capabilities for the new session.\n   * @param {promise.ControlFlow=} opt_flow The control flow all driver\n   *     commands should execute under, including the initial session creation.\n   *     Defaults to the {@link promise.controlFlow() currently active}\n   *     control flow.\n   * @param {(function(this: void): ?)=} opt_onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n\n\n  static createSession(executor, capabilities, opt_flow, opt_onQuit) {\n    let flow = opt_flow || promise.controlFlow();\n    let cmd = new command.Command(command.Name.NEW_SESSION);\n\n    if (capabilities && (capabilities.desired || capabilities.required)) {\n      cmd.setParameter('desiredCapabilities', capabilities.desired);\n      cmd.setParameter('requiredCapabilities', capabilities.required);\n    } else {\n      cmd.setParameter('desiredCapabilities', capabilities);\n    }\n\n    let session = flow.execute(() => executeCommand(executor, cmd), 'WebDriver.createSession()');\n\n    if (typeof opt_onQuit === 'function') {\n      session = session.catch(err => {\n        return Promise.resolve(opt_onQuit.call(void 0)).then(_ => {\n          throw err;\n        });\n      });\n    }\n\n    return new this(session, executor, flow, opt_onQuit);\n  }\n  /** @override */\n\n\n  controlFlow() {\n    return this.flow_;\n  }\n  /** @override */\n\n\n  schedule(command, description) {\n    command.setParameter('sessionId', this.session_); // If any of the command parameters are rejected promises, those\n    // rejections may be reported as unhandled before the control flow\n    // attempts to execute the command. To ensure parameters errors\n    // propagate through the command itself, we resolve all of the\n    // command parameters now, but suppress any errors until the ControlFlow\n    // actually executes the command. This addresses scenarios like catching\n    // an element not found error in:\n    //\n    //     driver.findElement(By.id('foo')).click().catch(function(e) {\n    //       if (e instanceof NoSuchElementError) {\n    //         // Do something.\n    //       }\n    //     });\n\n    var prepCommand = toWireValue(command.getParameters());\n    prepCommand.catch(function () {});\n    var flow = this.flow_;\n    var executor = this.executor_;\n    return flow.execute(() => {\n      // Retrieve resolved command parameters; any previously suppressed errors\n      // will now propagate up through the control flow as part of the command\n      // execution.\n      return prepCommand.then(function (parameters) {\n        command.setParameters(parameters);\n        return executor.execute(command);\n      }).then(value => fromWireValue(this, value));\n    }, description);\n  }\n  /** @override */\n\n\n  setFileDetector(detector) {\n    this.fileDetector_ = detector;\n  }\n  /** @override */\n\n\n  getExecutor() {\n    return this.executor_;\n  }\n  /** @override */\n\n\n  getSession() {\n    return this.session_;\n  }\n  /** @override */\n\n\n  getCapabilities() {\n    return this.session_.then(s => s.getCapabilities());\n  }\n  /** @override */\n\n\n  quit() {\n    var result = this.schedule(new command.Command(command.Name.QUIT), 'WebDriver.quit()'); // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n\n    return (\n      /** @type {!promise.Thenable} */\n      promise.finally(result, () => {\n        this.session_ = this.flow_.promise((_, reject) => {\n          reject(new error.NoSuchSessionError('This driver instance does not have a valid session ID ' + '(did you call WebDriver.quit()?) and may no longer be used.'));\n        }); // Only want the session rejection to bubble if accessed.\n\n        this.session_.catch(function () {});\n\n        if (this.onQuit_) {\n          return this.onQuit_.call(void 0);\n        }\n      })\n    );\n  }\n  /** @override */\n\n\n  actions() {\n    return new actions.ActionSequence(this);\n  }\n  /** @override */\n\n\n  touchActions() {\n    return new actions.TouchSequence(this);\n  }\n  /** @override */\n\n\n  executeScript(script, var_args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n\n    let args = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];\n    return this.schedule(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', args), 'WebDriver.executeScript()');\n  }\n  /** @override */\n\n\n  executeAsyncScript(script, var_args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n    return this.schedule(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', args), 'WebDriver.executeScript()');\n  }\n  /** @override */\n\n\n  call(fn, opt_scope, var_args) {\n    let args = Array.prototype.slice.call(arguments, 2);\n    return this.flow_.execute(function () {\n      return promise.fullyResolved(args).then(function (args) {\n        if (promise.isGenerator(fn)) {\n          args.unshift(fn, opt_scope);\n          return promise.consume.apply(null, args);\n        }\n\n        return fn.apply(opt_scope, args);\n      });\n    }, 'WebDriver.call(' + (fn.name || 'function') + ')');\n  }\n  /** @override */\n\n\n  wait(condition, opt_timeout, opt_message) {\n    if (promise.isPromise(condition)) {\n      return this.flow_.wait(\n      /** @type {!IThenable} */\n      condition, opt_timeout, opt_message);\n    }\n\n    var message = opt_message;\n    var fn =\n    /** @type {!Function} */\n    condition;\n\n    if (condition instanceof Condition) {\n      message = message || condition.description();\n      fn = condition.fn;\n    }\n\n    if (typeof fn !== 'function') {\n      throw TypeError('Wait condition must be a promise-like object, function, or a ' + 'Condition object');\n    }\n\n    var driver = this;\n    var result = this.flow_.wait(function () {\n      if (promise.isGenerator(fn)) {\n        return promise.consume(fn, null, [driver]);\n      }\n\n      return fn(driver);\n    }, opt_timeout, message);\n\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(this, result.then(function (value) {\n        if (!(value instanceof WebElement)) {\n          throw TypeError('WebElementCondition did not resolve to a WebElement: ' + Object.prototype.toString.call(value));\n        }\n\n        return value;\n      }));\n    }\n\n    return result;\n  }\n  /** @override */\n\n\n  sleep(ms) {\n    return this.flow_.timeout(ms, 'WebDriver.sleep(' + ms + ')');\n  }\n  /** @override */\n\n\n  getWindowHandle() {\n    return this.schedule(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE), 'WebDriver.getWindowHandle()');\n  }\n  /** @override */\n\n\n  getAllWindowHandles() {\n    return this.schedule(new command.Command(command.Name.GET_WINDOW_HANDLES), 'WebDriver.getAllWindowHandles()');\n  }\n  /** @override */\n\n\n  getPageSource() {\n    return this.schedule(new command.Command(command.Name.GET_PAGE_SOURCE), 'WebDriver.getPageSource()');\n  }\n  /** @override */\n\n\n  close() {\n    return this.schedule(new command.Command(command.Name.CLOSE), 'WebDriver.close()');\n  }\n  /** @override */\n\n\n  get(url) {\n    return this.navigate().to(url);\n  }\n  /** @override */\n\n\n  getCurrentUrl() {\n    return this.schedule(new command.Command(command.Name.GET_CURRENT_URL), 'WebDriver.getCurrentUrl()');\n  }\n  /** @override */\n\n\n  getTitle() {\n    return this.schedule(new command.Command(command.Name.GET_TITLE), 'WebDriver.getTitle()');\n  }\n  /** @override */\n\n\n  findElement(locator) {\n    let id;\n    locator = by.checkedLocator(locator);\n\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.schedule(cmd, 'WebDriver.findElement(' + locator + ')');\n    }\n\n    return new WebElementPromise(this, id);\n  }\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search\n   *     context.\n   * @return {!promise.Thenable<!WebElement>} A\n   *     promise that will resolve to a list of WebElements.\n   * @private\n   */\n\n\n  findElementInternal_(locatorFn, context) {\n    return this.call(() => locatorFn(context)).then(function (result) {\n      if (Array.isArray(result)) {\n        result = result[0];\n      }\n\n      if (!(result instanceof WebElement)) {\n        throw new TypeError('Custom locator did not return a WebElement');\n      }\n\n      return result;\n    });\n  }\n  /** @override */\n\n\n  findElements(locator) {\n    locator = by.checkedLocator(locator);\n\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n      return this.schedule(cmd, 'WebDriver.findElements(' + locator + ')').then(res => Array.isArray(res) ? res : [], e => {\n        if (e instanceof error.NoSuchElementError) {\n          return [];\n        }\n\n        throw e;\n      });\n    }\n  }\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A promise that\n   *     will resolve to an array of WebElements.\n   * @private\n   */\n\n\n  findElementsInternal_(locatorFn, context) {\n    return this.call(() => locatorFn(context)).then(function (result) {\n      if (result instanceof WebElement) {\n        return [result];\n      }\n\n      if (!Array.isArray(result)) {\n        return [];\n      }\n\n      return result.filter(function (item) {\n        return item instanceof WebElement;\n      });\n    });\n  }\n  /** @override */\n\n\n  takeScreenshot() {\n    return this.schedule(new command.Command(command.Name.SCREENSHOT), 'WebDriver.takeScreenshot()');\n  }\n  /** @override */\n\n\n  manage() {\n    return new Options(this);\n  }\n  /** @override */\n\n\n  navigate() {\n    return new Navigation(this);\n  }\n  /** @override */\n\n\n  switchTo() {\n    return new TargetLocator(this);\n  }\n\n}\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\n\n\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command to navigate to a new URL.\n   * @param {string} url The URL to navigate to.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the URL has been loaded.\n   */\n\n\n  to(url) {\n    return this.driver_.schedule(new command.Command(command.Name.GET).setParameter('url', url), 'WebDriver.navigate().to(' + url + ')');\n  }\n  /**\n   * Schedules a command to move backwards in the browser history.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n\n\n  back() {\n    return this.driver_.schedule(new command.Command(command.Name.GO_BACK), 'WebDriver.navigate().back()');\n  }\n  /**\n   * Schedules a command to move forwards in the browser history.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n\n\n  forward() {\n    return this.driver_.schedule(new command.Command(command.Name.GO_FORWARD), 'WebDriver.navigate().forward()');\n  }\n  /**\n   * Schedules a command to refresh the current page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n\n\n  refresh() {\n    return this.driver_.schedule(new command.Command(command.Name.REFRESH), 'WebDriver.navigate().refresh()');\n  }\n\n}\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\n\n\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command to add a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n\n\n  addCookie({\n    name,\n    value,\n    path,\n    domain,\n    secure,\n    httpOnly,\n    expiry\n  }) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"');\n    } // We do not allow ';' in value.\n\n\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError('Invalid cookie value \"' + value + '\"');\n    }\n\n    let cookieString = name + '=' + value + (domain ? ';domain=' + domain : '') + (path ? ';path=' + path : '') + (secure ? ';secure' : '');\n\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry);\n      cookieString += ';expires=' + new Date(expiry * 1000).toUTCString();\n    } else if (expiry instanceof Date) {\n      let date =\n      /** @type {!Date} */\n      expiry;\n      expiry = Math.floor(date.getTime() / 1000);\n      cookieString += ';expires=' + date.toUTCString();\n    }\n\n    return this.driver_.schedule(new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n      'name': name,\n      'value': value,\n      'path': path,\n      'domain': domain,\n      'secure': !!secure,\n      'httpOnly': !!httpOnly,\n      'expiry': expiry\n    }), 'WebDriver.manage().addCookie(' + cookieString + ')');\n  }\n  /**\n   * Schedules a command to delete all cookies visible to the current page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n\n\n  deleteAllCookies() {\n    return this.driver_.schedule(new command.Command(command.Name.DELETE_ALL_COOKIES), 'WebDriver.manage().deleteAllCookies()');\n  }\n  /**\n   * Schedules a command to delete the cookie with the given name. This command\n   * is a no-op if there is no cookie with the given name visible to the current\n   * page.\n   * @param {string} name The name of the cookie to delete.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n\n\n  deleteCookie(name) {\n    return this.driver_.schedule(new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name), 'WebDriver.manage().deleteCookie(' + name + ')');\n  }\n  /**\n   * Schedules a command to retrieve all cookies visible to the current page.\n   * Each cookie will be returned as a JSON object as described by the WebDriver\n   * wire protocol.\n   * @return {!promise.Thenable<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n\n\n  getCookies() {\n    return this.driver_.schedule(new command.Command(command.Name.GET_ALL_COOKIES), 'WebDriver.manage().getCookies()');\n  }\n  /**\n   * Schedules a command to retrieve the cookie with the given name. Returns null\n   * if there is no such cookie. The cookie will be returned as a JSON object as\n   * described by the WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!promise.Thenable<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie, or `null` if there is no such cookie.\n   */\n\n\n  getCookie(name) {\n    return this.getCookies().then(function (cookies) {\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie;\n        }\n      }\n\n      return null;\n    });\n  }\n  /**\n   * Schedules a command to fetch the timeouts currently configured for the\n   * current session.\n   *\n   * @return {!promise.Thenable<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n\n\n  getTimeouts() {\n    return this.driver_.schedule(new command.Command(command.Name.GET_TIMEOUT), `WebDriver.manage().getTimeouts()`);\n  }\n  /**\n   * Schedules a command to set timeout durations associated with the current\n   * session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!promise.Thenable<void>} A promise that will be resolved when the\n   *     timeouts have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n\n\n  setTimeouts({\n    script,\n    pageLoad,\n    implicit\n  } = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT);\n    let valid = false;\n\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true;\n        cmd.setParameter(key, value);\n      } else if (typeof value !== 'undefined') {\n        throw TypeError('invalid timeouts configuration:' + ` expected \"${key}\" to be a number, got ${typeof value}`);\n      }\n    }\n\n    setParam('implicit', implicit);\n    setParam('pageLoad', pageLoad);\n    setParam('script', script);\n\n    if (valid) {\n      return this.driver_.schedule(cmd, `WebDriver.manage().setTimeouts()`).catch(() => {\n        // Fallback to the legacy method.\n        let cmds = [];\n\n        if (typeof script === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'script', script));\n        }\n\n        if (typeof implicit === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'implicit', implicit));\n        }\n\n        if (typeof pageLoad === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad));\n        }\n\n        return Promise.all(cmds);\n      });\n    }\n\n    throw TypeError('no timeouts specified');\n  }\n  /**\n   * @return {!Logs} The interface for managing driver\n   *     logs.\n   */\n\n\n  logs() {\n    return new Logs(this.driver_);\n  }\n  /**\n   * @return {!Timeouts} The interface for managing driver timeouts.\n   * @deprecated Use {@link #setTimeouts()} instead.\n   */\n\n\n  timeouts() {\n    return new Timeouts(this.driver_);\n  }\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n\n\n  window() {\n    return new Window(this.driver_);\n  }\n\n}\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!promise.Thenable<void>}\n */\n\n\nfunction legacyTimeout(driver, type, ms) {\n  return driver.schedule(new command.Command(command.Name.SET_TIMEOUT).setParameter('type', type).setParameter('ms', ms), `WebDriver.manage().setTimeouts({${type}: ${ms}})`);\n}\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\n\n\nOptions.Cookie = function () {};\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\n\n\nOptions.Cookie.prototype.name;\n/**\n * The cookie value.\n *\n * @type {string}\n */\n\nOptions.Cookie.prototype.value;\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\n\nOptions.Cookie.prototype.path;\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\n\nOptions.Cookie.prototype.domain;\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\n\nOptions.Cookie.prototype.secure;\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\n\nOptions.Cookie.prototype.httpOnly;\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\n\nOptions.Cookie.prototype.expiry;\n/**\n * An interface for managing timeout behavior for WebDriver instances.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().timeouts()\n *\n * @deprecated This has been deprecated in favor of\n *     {@link Options#setTimeouts()}, which supports setting multiple timeouts\n *     at once.\n * @see WebDriver#manage()\n * @see Options#timeouts()\n */\n\nclass Timeouts {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Specifies the amount of time the driver should wait when searching for an\n   * element if it is not immediately present.\n   *\n   * When searching for a single element, the driver should poll the page\n   * until the element has been found, or this timeout expires before failing\n   * with a {@link bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching\n   * for multiple elements, the driver should poll the page until at least one\n   * element has been found or this timeout has expired.\n   *\n   * Setting the wait timeout to 0 (its default value), disables implicit\n   * waiting.\n   *\n   * Increasing the implicit wait timeout should be used judiciously as it\n   * will have an adverse effect on test run time, especially when used with\n   * slower location strategies like XPath.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the implicit wait timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({implicit: ms})}.\n   */\n\n\n  implicitlyWait(ms) {\n    return this.driver_.manage().setTimeouts({\n      implicit: ms\n    });\n  }\n  /**\n   * Sets the amount of time to wait, in milliseconds, for an asynchronous\n   * script to finish execution before returning an error. If the timeout is\n   * less than or equal to 0, the script will be allowed to run indefinitely.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the script timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({script: ms})}.\n   */\n\n\n  setScriptTimeout(ms) {\n    return this.driver_.manage().setTimeouts({\n      script: ms\n    });\n  }\n  /**\n   * Sets the amount of time to wait for a page load to complete before\n   * returning an error.  If the timeout is negative, page loads may be\n   * indefinite.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({pageLoad: ms})}.\n   */\n\n\n  pageLoadTimeout(ms) {\n    return this.driver_.manage().setTimeouts({\n      pageLoad: ms\n    });\n  }\n\n}\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\n\n\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Retrieves the window's current position, relative to the top left corner of\n   * the screen.\n   * @return {!promise.Thenable<{x: number, y: number}>} A promise\n   *     that will be resolved with the window's position in the form of a\n   *     {x:number, y:number} object literal.\n   */\n\n\n  getPosition() {\n    return this.driver_.schedule(new command.Command(command.Name.GET_WINDOW_POSITION).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().getPosition()');\n  }\n  /**\n   * Repositions the current window.\n   * @param {number} x The desired horizontal position, relative to the left\n   *     side of the screen.\n   * @param {number} y The desired vertical position, relative to the top of the\n   *     of the screen.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n\n\n  setPosition(x, y) {\n    return this.driver_.schedule(new command.Command(command.Name.SET_WINDOW_POSITION).setParameter('windowHandle', 'current').setParameter('x', x).setParameter('y', y), 'WebDriver.manage().window().setPosition(' + x + ', ' + y + ')');\n  }\n  /**\n   * Retrieves the window's current size.\n   * @return {!promise.Thenable<{width: number, height: number}>} A\n   *     promise that will be resolved with the window's size in the form of a\n   *     {width:number, height:number} object literal.\n   */\n\n\n  getSize() {\n    return this.driver_.schedule(new command.Command(command.Name.GET_WINDOW_SIZE).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().getSize()');\n  }\n  /**\n   * Resizes the current window.\n   * @param {number} width The desired window width.\n   * @param {number} height The desired window height.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n\n\n  setSize(width, height) {\n    return this.driver_.schedule(new command.Command(command.Name.SET_WINDOW_SIZE).setParameter('windowHandle', 'current').setParameter('width', width).setParameter('height', height), 'WebDriver.manage().window().setSize(' + width + ', ' + height + ')');\n  }\n  /**\n   * Maximizes the current window.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n\n\n  maximize() {\n    return this.driver_.schedule(new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().maximize()');\n  }\n\n}\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\n\n\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!promise.Thenable<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n\n\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type);\n    return this.driver_.schedule(cmd, 'WebDriver.manage().logs().get(' + type + ')').then(function (entries) {\n      return entries.map(function (entry) {\n        if (!(entry instanceof logging.Entry)) {\n          return new logging.Entry(entry['level'], entry['message'], entry['timestamp'], entry['type']);\n        }\n\n        return entry;\n      });\n    });\n  }\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!promise.Thenable<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n\n\n  getAvailableLogTypes() {\n    return this.driver_.schedule(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES), 'WebDriver.manage().logs().getAvailableLogTypes()');\n  }\n\n}\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\n\n\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command retrieve the {@code document.activeElement} element on\n   * the current document, or {@code document.body} if activeElement is not\n   * available.\n   * @return {!WebElementPromise} The active element.\n   */\n\n\n  activeElement() {\n    var id = this.driver_.schedule(new command.Command(command.Name.GET_ACTIVE_ELEMENT), 'WebDriver.switchTo().activeElement()');\n    return new WebElementPromise(this.driver_, id);\n  }\n  /**\n   * Schedules a command to switch focus of all future commands to the topmost\n   * frame on the page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n\n\n  defaultContent() {\n    return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null), 'WebDriver.switchTo().defaultContent()');\n  }\n  /**\n   * Schedules a command to switch the focus of all future commands to another\n   * frame on the page. The target frame may be specified as one of the\n   * following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|WebElement|null)} id The frame locator.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n\n\n  frame(id) {\n    return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', id), 'WebDriver.switchTo().frame(' + id + ')');\n  }\n  /**\n   * Schedules a command to switch the focus of all future commands to another\n   * window. Windows may be specified by their {@code window.name} attribute or\n   * by its handle (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n\n\n  window(nameOrHandle) {\n    return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_WINDOW). // \"name\" supports the legacy drivers. \"handle\" is the W3C\n    // compliant parameter.\n    setParameter('name', nameOrHandle).setParameter('handle', nameOrHandle), 'WebDriver.switchTo().window(' + nameOrHandle + ')');\n  }\n  /**\n   * Schedules a command to change focus to the active modal dialog, such as\n   * those opened by `window.alert()`, `window.confirm()`, and\n   * `window.prompt()`. The returned promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n\n\n  alert() {\n    var text = this.driver_.schedule(new command.Command(command.Name.GET_ALERT_TEXT), 'WebDriver.switchTo().alert()');\n    var driver = this.driver_;\n    return new AlertPromise(driver, text.then(function (text) {\n      return new Alert(driver, text);\n    }));\n  }\n\n} //////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\n\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n    /** @private {!promise.Thenable<string>} */\n\n    this.id_ = driver.controlFlow().promise(resolve => resolve(id));\n  }\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} opt_noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n\n\n  static buildId(id, opt_noLegacy) {\n    return opt_noLegacy ? {\n      [ELEMENT_ID_KEY]: id\n    } : {\n      [ELEMENT_ID_KEY]: id,\n      [LEGACY_ELEMENT_ID_KEY]: id\n    };\n  }\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n\n\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[ELEMENT_ID_KEY] === 'string') {\n        return obj[ELEMENT_ID_KEY];\n      } else if (typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string') {\n        return obj[LEGACY_ELEMENT_ID_KEY];\n      }\n    }\n\n    throw new TypeError('object is not a WebElement ID');\n  }\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n\n\n  static isId(obj) {\n    return obj && typeof obj === 'object' && (typeof obj[ELEMENT_ID_KEY] === 'string' || typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string');\n  }\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n\n\n  static equals(a, b) {\n    if (a === b) {\n      return a.driver_.controlFlow().promise(resolve => resolve(true));\n    }\n\n    let ids = [a.getId(), b.getId()];\n    return promise.all(ids).then(function (ids) {\n      // If the two element's have the same ID, they should be considered\n      // equal. Otherwise, they may still be equivalent, but we'll need to\n      // ask the server to check for us.\n      if (ids[0] === ids[1]) {\n        return true;\n      }\n\n      let cmd = new command.Command(command.Name.ELEMENT_EQUALS);\n      cmd.setParameter('id', ids[0]);\n      cmd.setParameter('other', ids[1]);\n      return a.driver_.schedule(cmd, 'WebElement.equals()');\n    });\n  }\n  /** @return {!WebDriver} The parent driver for this instance. */\n\n\n  getDriver() {\n    return this.driver_;\n  }\n  /**\n   * @return {!promise.Thenable<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n\n\n  getId() {\n    return this.id_;\n  }\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n\n\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId);\n  }\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @param {string} description A description of the command for debugging.\n   * @return {!promise.Thenable<T>} A promise that will be resolved\n   *     with the command result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n\n\n  schedule_(command, description) {\n    command.setParameter('id', this);\n    return this.driver_.schedule(command, description);\n  }\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n\n\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.schedule_(cmd, 'WebElement.findElement(' + locator + ')');\n    }\n\n    return new WebElementPromise(this.driver_, id);\n  }\n  /**\n   * Schedules a command to find all of the descendants of this element that\n   * match the given search criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A\n   *     promise that will resolve to an array of WebElements.\n   */\n\n\n  findElements(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      var cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n      return this.schedule_(cmd, 'WebElement.findElements(' + locator + ')').then(result => Array.isArray(result) ? result : []);\n    }\n  }\n  /**\n   * Schedules a command to click on this element.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the click command has completed.\n   */\n\n\n  click() {\n    return this.schedule_(new command.Command(command.Name.CLICK_ELEMENT), 'WebElement.click()');\n  }\n  /**\n   * Schedules a command to type a sequence on the DOM element represented by\n   * this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} var_args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when all keys have been typed.\n   */\n\n\n  sendKeys(var_args) {\n    let keys = Promise.all(Array.prototype.slice.call(arguments, 0)).then(keys => {\n      let ret = [];\n      keys.forEach(key => {\n        let type = typeof key;\n\n        if (type === 'number') {\n          key = String(key);\n        } else if (type !== 'string') {\n          throw TypeError('each key must be a number of string; got ' + type);\n        } // The W3C protocol requires keys to be specified as an array where\n        // each element is a single key.\n\n\n        ret.push.apply(ret, key.split(''));\n      });\n      return ret;\n    });\n\n    if (!this.driver_.fileDetector_) {\n      return this.schedule_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys.then(keys => keys.join(''))).setParameter('value', keys), 'WebElement.sendKeys()');\n    } // Suppress unhandled rejection errors until the flow executes the command.\n\n\n    keys.catch(function () {});\n    var element = this;\n    return this.getDriver().controlFlow().execute(function () {\n      return keys.then(function (keys) {\n        return element.driver_.fileDetector_.handleFile(element.driver_, keys.join(''));\n      }).then(function (keys) {\n        return element.schedule_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys).setParameter('value', keys.split('')), 'WebElement.sendKeys()');\n      });\n    }, 'WebElement.sendKeys()');\n  }\n  /**\n   * Schedules a command to query for the tag/node name of this element.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the element's tag name.\n   */\n\n\n  getTagName() {\n    return this.schedule_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME), 'WebElement.getTagName()');\n  }\n  /**\n   * Schedules a command to query for the computed style of the element\n   * represented by this instance. If the element inherits the named style from\n   * its parent, the parent will be queried for its value.  Where possible, color\n   * values will be converted to their hex representation (e.g. #00ff00 instead\n   * of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the requested CSS value.\n   */\n\n\n  getCssValue(cssStyleProperty) {\n    var name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n    return this.schedule_(new command.Command(name).setParameter('propertyName', cssStyleProperty), 'WebElement.getCssValue(' + cssStyleProperty + ')');\n  }\n  /**\n   * Schedules a command to query for the value of the given attribute of the\n   * element. Will return the current value, even if it has been modified after\n   * the page has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semi-colon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!promise.Thenable<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n\n\n  getAttribute(attributeName) {\n    return this.schedule_(new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter('name', attributeName), 'WebElement.getAttribute(' + attributeName + ')');\n  }\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n\n\n  getText() {\n    return this.schedule_(new command.Command(command.Name.GET_ELEMENT_TEXT), 'WebElement.getText()');\n  }\n  /**\n   * Schedules a command to compute the size of this element's bounding box, in\n   * pixels.\n   * @return {!promise.Thenable<{width: number, height: number}>} A\n   *     promise that will be resolved with the element's size as a\n   *     {@code {width:number, height:number}} object.\n   */\n\n\n  getSize() {\n    return this.schedule_(new command.Command(command.Name.GET_ELEMENT_SIZE), 'WebElement.getSize()');\n  }\n  /**\n   * Schedules a command to compute the location of this element in page space.\n   * @return {!promise.Thenable<{x: number, y: number}>} A promise that\n   *     will be resolved to the element's location as a\n   *     {@code {x:number, y:number}} object.\n   */\n\n\n  getLocation() {\n    return this.schedule_(new command.Command(command.Name.GET_ELEMENT_LOCATION), 'WebElement.getLocation()');\n  }\n  /**\n   * Schedules a command to query whether the DOM element represented by this\n   * instance is enabled, as dictated by the {@code disabled} attribute.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n\n\n  isEnabled() {\n    return this.schedule_(new command.Command(command.Name.IS_ELEMENT_ENABLED), 'WebElement.isEnabled()');\n  }\n  /**\n   * Schedules a command to query whether this element is selected.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n\n\n  isSelected() {\n    return this.schedule_(new command.Command(command.Name.IS_ELEMENT_SELECTED), 'WebElement.isSelected()');\n  }\n  /**\n   * Schedules a command to submit the form containing this element (or this\n   * element if it is a FORM element). This command is a no-op if the element is\n   * not contained in a form.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n\n\n  submit() {\n    return this.schedule_(new command.Command(command.Name.SUBMIT_ELEMENT), 'WebElement.submit()');\n  }\n  /**\n   * Schedules a command to clear the `value` of this element. This command has\n   * no effect if the underlying DOM element is neither a text INPUT element\n   * nor a TEXTAREA element.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n\n\n  clear() {\n    return this.schedule_(new command.Command(command.Name.CLEAR_ELEMENT), 'WebElement.clear()');\n  }\n  /**\n   * Schedules a command to test whether this element is currently displayed.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n\n\n  isDisplayed() {\n    return this.schedule_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED), 'WebElement.isDisplayed()');\n  }\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @param {boolean=} opt_scroll Optional argument that indicates whether the\n   *     element should be scrolled into view before taking a screenshot.\n   *     Defaults to false.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n\n\n  takeScreenshot(opt_scroll) {\n    var scroll = !!opt_scroll;\n    return this.schedule_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT).setParameter('scroll', scroll), 'WebElement.takeScreenshot(' + scroll + ')');\n  }\n\n}\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {promise.CancellableThenable<!WebElement>}\n * @final\n */\n\n\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!promise.Thenable<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused');\n    /**\n     * Cancel operation is only supported if the wrapped thenable is also\n     * cancellable.\n     * @param {(string|Error)=} opt_reason\n     * @override\n     */\n\n    this.cancel = function (opt_reason) {\n      if (promise.CancellableThenable.isImplementation(el)) {\n        /** @type {!promise.CancellableThenable} */\n        el.cancel(opt_reason);\n      }\n    };\n    /** @override */\n\n\n    this.then = el.then.bind(el);\n    /** @override */\n\n    this.catch = el.catch.bind(el);\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n\n    this.getId = function () {\n      return el.then(function (el) {\n        return el.getId();\n      });\n    };\n  }\n\n}\n\npromise.CancellableThenable.addImplementation(WebElementPromise); //////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\n\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n    /** @private {!promise.Thenable<string>} */\n\n    this.text_ = driver.controlFlow().promise(resolve => resolve(text));\n  }\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n\n\n  getText() {\n    return this.text_;\n  }\n  /**\n   * Sets the username and password in an alert prompting for credentials (such\n   * as a Basic HTTP Auth prompt). This method will implicitly\n   * {@linkplain #accept() submit} the dialog.\n   *\n   * @param {string} username The username to send.\n   * @param {string} password The password to send.\n   * @return {!promise.Thenable<void>} A promise that will be resolved when this\n   *     command has completed.\n   */\n\n\n  authenticateAs(username, password) {\n    return this.driver_.schedule(new command.Command(command.Name.SET_ALERT_CREDENTIALS), 'WebDriver.switchTo().alert()' + `.authenticateAs(\"${username}\", \"${password}\")`);\n  }\n  /**\n   * Accepts this alert.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n\n\n  accept() {\n    return this.driver_.schedule(new command.Command(command.Name.ACCEPT_ALERT), 'WebDriver.switchTo().alert().accept()');\n  }\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n\n\n  dismiss() {\n    return this.driver_.schedule(new command.Command(command.Name.DISMISS_ALERT), 'WebDriver.switchTo().alert().dismiss()');\n  }\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n\n\n  sendKeys(text) {\n    return this.driver_.schedule(new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text), 'WebDriver.switchTo().alert().sendKeys(' + text + ')');\n  }\n\n}\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {promise.CancellableThenable<!webdriver.Alert>}\n * @final\n */\n\n\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!promise.Thenable<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused');\n    /**\n     * Cancel operation is only supported if the wrapped thenable is also\n     * cancellable.\n     * @param {(string|Error)=} opt_reason\n     * @override\n     */\n\n    this.cancel = function (opt_reason) {\n      if (promise.CancellableThenable.isImplementation(alert)) {\n        /** @type {!promise.CancellableThenable} */\n        alert.cancel(opt_reason);\n      }\n    };\n    /** @override */\n\n\n    this.then = alert.then.bind(alert);\n    /** @override */\n\n    this.catch = alert.catch.bind(alert);\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n\n    this.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    this.authenticateAs = function (username, password) {\n      return alert.then(function (alert) {\n        return alert.authenticateAs(username, password);\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    this.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    this.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    this.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text);\n      });\n    };\n  }\n\n}\n\npromise.CancellableThenable.addImplementation(AlertPromise); // PUBLIC API\n\nmodule.exports = {\n  Alert: Alert,\n  AlertPromise: AlertPromise,\n  Condition: Condition,\n  Logs: Logs,\n  Navigation: Navigation,\n  Options: Options,\n  TargetLocator: TargetLocator,\n  Timeouts: Timeouts,\n  IWebDriver: IWebDriver,\n  WebDriver: WebDriver,\n  WebElement: WebElement,\n  WebElementCondition: WebElementCondition,\n  WebElementPromise: WebElementPromise,\n  Window: Window\n};","map":{"version":3,"sources":["/Users/dariya/Documents/GitHub/Web-development/lab 4&5/wgg87w--run/node_modules/selenium-webdriver/lib/webdriver.js"],"names":["actions","require","by","Capabilities","command","error","input","logging","Session","Symbols","promise","Condition","constructor","message","fn","description_","description","WebElementCondition","executeCommand","executor","toWireValue","getParameters","then","parameters","setParameters","execute","obj","isPromise","Promise","resolve","convertValue","value","Array","isArray","convertKeys","serialize","toJSON","numKeys","length","Object","keys","ret","numResolved","forEachKey","i","n","key","done","reject","setValue","maybeFulfill","fromWireValue","driver","map","v","WebElement","isId","id","extractId","result","hasOwnProperty","IWebDriver","controlFlow","schedule","setFileDetector","detector","getExecutor","getSession","getCapabilities","quit","touchActions","executeScript","script","var_args","executeAsyncScript","call","opt_scope","wait","condition","opt_timeout","opt_message","sleep","ms","getWindowHandle","getAllWindowHandles","getPageSource","close","get","url","getCurrentUrl","getTitle","findElement","locator","findElements","takeScreenshot","manage","navigate","switchTo","WebDriver","session","opt_flow","opt_onQuit","flow_","session_","executor_","fileDetector_","onQuit_","attachToSession","sessionId","flow","cmd","Command","Name","DESCRIBE_SESSION","setParameter","catch","err","UnknownCommandError","createSession","capabilities","NEW_SESSION","desired","required","_","prepCommand","s","QUIT","finally","NoSuchSessionError","ActionSequence","TouchSequence","args","arguments","prototype","slice","EXECUTE_SCRIPT","EXECUTE_ASYNC_SCRIPT","fullyResolved","isGenerator","unshift","consume","apply","name","TypeError","WebElementPromise","toString","timeout","GET_CURRENT_WINDOW_HANDLE","GET_WINDOW_HANDLES","GET_PAGE_SOURCE","CLOSE","to","GET_CURRENT_URL","GET_TITLE","checkedLocator","findElementInternal_","FIND_ELEMENT","using","locatorFn","context","findElementsInternal_","FIND_ELEMENTS","res","e","NoSuchElementError","filter","item","SCREENSHOT","Options","Navigation","TargetLocator","driver_","GET","back","GO_BACK","forward","GO_FORWARD","refresh","REFRESH","addCookie","path","domain","secure","httpOnly","expiry","test","InvalidArgumentError","cookieString","Math","floor","Date","toUTCString","date","getTime","ADD_COOKIE","deleteAllCookies","DELETE_ALL_COOKIES","deleteCookie","DELETE_COOKIE","getCookies","GET_ALL_COOKIES","getCookie","cookies","cookie","getTimeouts","GET_TIMEOUT","setTimeouts","pageLoad","implicit","SET_TIMEOUT","valid","setParam","cmds","push","legacyTimeout","all","logs","Logs","timeouts","Timeouts","window","Window","type","Cookie","implicitlyWait","setScriptTimeout","pageLoadTimeout","getPosition","GET_WINDOW_POSITION","setPosition","x","y","SET_WINDOW_POSITION","getSize","GET_WINDOW_SIZE","setSize","width","height","SET_WINDOW_SIZE","maximize","MAXIMIZE_WINDOW","GET_LOG","entries","entry","Entry","getAvailableLogTypes","GET_AVAILABLE_LOG_TYPES","activeElement","GET_ACTIVE_ELEMENT","defaultContent","SWITCH_TO_FRAME","frame","nameOrHandle","SWITCH_TO_WINDOW","alert","text","GET_ALERT_TEXT","AlertPromise","Alert","LEGACY_ELEMENT_ID_KEY","ELEMENT_ID_KEY","id_","buildId","opt_noLegacy","equals","a","b","ids","getId","ELEMENT_EQUALS","getDriver","schedule_","FIND_CHILD_ELEMENT","FIND_CHILD_ELEMENTS","click","CLICK_ELEMENT","sendKeys","forEach","String","split","SEND_KEYS_TO_ELEMENT","join","element","handleFile","getTagName","GET_ELEMENT_TAG_NAME","getCssValue","cssStyleProperty","GET_ELEMENT_VALUE_OF_CSS_PROPERTY","getAttribute","attributeName","GET_ELEMENT_ATTRIBUTE","getText","GET_ELEMENT_TEXT","GET_ELEMENT_SIZE","getLocation","GET_ELEMENT_LOCATION","isEnabled","IS_ELEMENT_ENABLED","isSelected","IS_ELEMENT_SELECTED","submit","SUBMIT_ELEMENT","clear","CLEAR_ELEMENT","isDisplayed","IS_ELEMENT_DISPLAYED","opt_scroll","scroll","TAKE_ELEMENT_SCREENSHOT","el","cancel","opt_reason","CancellableThenable","isImplementation","bind","addImplementation","text_","authenticateAs","username","password","SET_ALERT_CREDENTIALS","accept","ACCEPT_ALERT","dismiss","DISMISS_ALERT","SET_ALERT_TEXT","module","exports"],"mappings":"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A,QAAQ,CAAC3D,OAAD,EAAUY,WAAV,EAAuB,CAAE;AAEjC;AACF;AACA;AACA;AACA;;;AACEgD,EAAAA,eAAe,CAACC,QAAD,EAAW,CAAE;AAE5B;AACF;AACA;;;AACEC,EAAAA,WAAW,GAAG,CAAE;AAEhB;AACF;AACA;;;AACEC,EAAAA,UAAU,GAAG,CAAE;AAEf;AACF;AACA;AACA;;;AACEC,EAAAA,eAAe,GAAG,CAAE;AAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,IAAI,GAAG,CAAE;AAET;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACErE,EAAAA,OAAO,GAAG,CAAE;AAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEsE,EAAAA,YAAY,GAAG,CAAE;AAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,aAAa,CAACC,MAAD,EAASC,QAAT,EAAmB,CAAE;AAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,kBAAkB,CAACF,MAAD,EAASC,QAAT,EAAmB,CAAE;AAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,IAAI,CAAC7D,EAAD,EAAK8D,SAAL,EAAgBH,QAAhB,EAA0B,CAAE;AAEhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEI,EAAAA,IAAI,CAACC,SAAD,EAAYC,WAAZ,EAAyBC,WAAzB,EAAsC,CAAE;AAE5C;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,KAAK,CAACC,EAAD,EAAK,CAAE;AAEZ;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,eAAe,GAAG,CAAE;AAEpB;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,mBAAmB,GAAG,CAAE;AAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,aAAa,GAAG,CAAE;AAElB;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,KAAK,GAAG,CAAE;AAEV;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,GAAG,CAACC,GAAD,EAAM,CAAE;AAEX;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,aAAa,GAAG,CAAE;AAElB;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,QAAQ,GAAG,CAAE;AAEb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,CAACC,OAAD,EAAU,CAAE;AAEvB;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,CAACD,OAAD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;AACA;AACA;;AACAb,OAAO,CAACuD,MAAR,CAAe1F,SAAf,CAAyBiD,MAAzB;AAGA;AACA;AACA;AACA;AACA;AACA;;AACAd,OAAO,CAACuD,MAAR,CAAe1F,SAAf,CAAyBkD,QAAzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAf,OAAO,CAACuD,MAAR,CAAe1F,SAAf,CAAyBmD,MAAzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMmC,QAAN,CAAe;AACb;AACF;AACA;AACA;AACE/M,EAAAA,WAAW,CAACwC,MAAD,EAAS;AAClB;AACA,SAAKuH,OAAL,GAAevH,MAAf;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE4K,EAAAA,cAAc,CAAC9I,EAAD,EAAK;AACjB,WAAO,KAAKyF,OAAL,CAAa5E,MAAb,GAAsB+G,WAAtB,CAAkC;AAACE,MAAAA,QAAQ,EAAE9H;AAAX,KAAlC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE+I,EAAAA,gBAAgB,CAAC/I,EAAD,EAAK;AACnB,WAAO,KAAKyF,OAAL,CAAa5E,MAAb,GAAsB+G,WAAtB,CAAkC;AAACtI,MAAAA,MAAM,EAAEU;AAAT,KAAlC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEgJ,EAAAA,eAAe,CAAChJ,EAAD,EAAK;AAClB,WAAO,KAAKyF,OAAL,CAAa5E,MAAb,GAAsB+G,WAAtB,CAAkC;AAACC,MAAAA,QAAQ,EAAE7H;AAAX,KAAlC,CAAP;AACD;;AAjEY;AAqEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM2I,MAAN,CAAa;AACX;AACF;AACA;AACA;AACEjN,EAAAA,WAAW,CAA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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n'use strict';\n\nconst actions = require('./actions');\nconst by = require('./by');\nconst Capabilities = require('./capabilities').Capabilities;\nconst command = require('./command');\nconst error = require('./error');\nconst input = require('./input');\nconst logging = require('./logging');\nconst {Session} = require('./session');\nconst Symbols = require('./symbols');\nconst promise = require('./promise');\n\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn;\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_;\n  }\n}\n\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn);\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).\n      then(function(parameters) {\n        command.setParameters(parameters);\n        return executor.execute(command);\n      });\n}\n\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nfunction toWireValue(obj) {\n  if (promise.isPromise(obj)) {\n    return Promise.resolve(obj).then(toWireValue);\n  }\n  return Promise.resolve(convertValue(obj));\n}\n\n\nfunction convertValue(value) {\n  if (value === void 0 || value === null) {\n    return value;\n  }\n\n  if (typeof value === 'boolean'\n      || typeof value === 'number'\n      || typeof value === 'string') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n  return convertKeys(value);\n}\n\n\nfunction convertKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  const ret = isArray ? new Array(numKeys) : {};\n  if (!numKeys) {\n    return Promise.resolve(ret);\n  }\n\n  let numResolved = 0;\n\n  function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        fn(obj[i], i);\n      }\n    } else {\n      for (let key in obj) {\n        fn(obj[key], key);\n      }\n    }\n  }\n\n  return new Promise(function(done, reject) {\n    forEachKey(obj, function(value, key) {\n      if (promise.isPromise(value)) {\n        value.then(toWireValue).then(setValue, reject);\n      } else {\n        value = convertValue(value);\n        if (promise.isPromise(value)) {\n          value.then(toWireValue).then(setValue, reject);\n        } else {\n          setValue(value);\n        }\n      }\n\n      function setValue(value) {\n        ret[key] = value;\n        maybeFulfill();\n      }\n    });\n\n    function maybeFulfill() {\n      if (++numResolved === numKeys) {\n        done(ret);\n      }\n    }\n  });\n}\n\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(v => fromWireValue(driver, v));\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (value && typeof value === 'object') {\n    let result = {};\n    for (let key in value) {\n      if (value.hasOwnProperty(key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n    value = result;\n  }\n  return value;\n}\n\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n\n  /** @return {!promise.ControlFlow} The control flow used by this instance. */\n  controlFlow() {}\n\n  /**\n   * Schedules a {@link command.Command} to be executed by this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @param {string} description A description of the command for debugging.\n   * @return {!promise.Thenable<T>} A promise that will be resolved\n   *     with the command result.\n   * @template T\n   */\n  schedule(command, description) {}\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or {@code null}.\n   */\n  setFileDetector(detector) {}\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!promise.Thenable<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!promise.Thenable<!Capabilities>} A promise that will resolve with\n   *     the this instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * scheduled for execution until {@link actions.ActionSequence#perform} is\n   * called. Example:\n   *\n   *     driver.actions().\n   *         mouseDown(element1).\n   *         mouseMove(element2).\n   *         mouseUp().\n   *         perform();\n   *\n   * @return {!actions.ActionSequence} A new action sequence for this instance.\n   */\n  actions() {}\n\n  /**\n   * Creates a new touch sequence using this driver. The sequence will not be\n   * scheduled for execution until {@link actions.TouchSequence#perform} is\n   * called. Example:\n   *\n   *     driver.touchActions().\n   *         tap(element1).\n   *         doubleTap(element2).\n   *         perform();\n   *\n   * @return {!actions.TouchSequence} A new touch sequence for this instance.\n   */\n  touchActions() {}\n\n  /**\n   * Schedules a command to execute JavaScript in the context of the currently\n   * selected frame or window. The script fragment will be executed as the body\n   * of an anonymous function. If the script is provided as a function object,\n   * that function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the {@code arguments} object.\n   * Arguments may be a boolean, number, string, or {@linkplain WebElement}.\n   * Arrays and objects may also be used as script arguments as long as each item\n   * adheres to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * {@code document} may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {!promise.Thenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script, var_args) {}\n\n  /**\n   * Schedules a command to execute asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the {@code arguments} object.\n   * Arguments may be a boolean, number, string, or {@code WebElement}.\n   * Arrays and objects may also be used as script arguments as long as each item\n   * adheres to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are finished\n   * by invoking the provided callback. This callback will always be injected\n   * into the executed function as the last argument, and thus may be referenced\n   * with {@code arguments[arguments.length - 1]}. The following steps will be\n   * taken for resolving this functions return value against the first argument\n   * to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a\n   *     {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so it\n   * should not reference any symbols not defined in the scope of the page under\n   * test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {!promise.Thenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeAsyncScript(script, var_args) {}\n\n  /**\n   * Schedules a command to execute a custom function.\n   * @param {function(...): (T|IThenable<T>)} fn The function to execute.\n   * @param {Object=} opt_scope The object in whose scope to execute the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   * @return {!promise.Thenable<T>} A promise that will be resolved'\n   *     with the function's result.\n   * @template T\n   */\n  call(fn, opt_scope, var_args) {}\n\n  /**\n   * Schedules a command to wait for a condition to hold. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@link promise.Promise promise}, the polling\n   * loop will wait for it to be resolved and use the resolved value for whether\n   * the condition has been satisfied. Note the resolution time for a promise\n   * is factored into whether a wait has timed out.\n   *\n   * Note, if the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     var button = driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *     button.click();\n   *\n   * This function may also be used to block the command flow on the resolution\n   * of any thenable promise object. When given a promise, the command will\n   * simply wait for its resolution before completing. A timeout may be provided\n   * to fail the command if the promise does not resolve before the timeout\n   * expires.\n   *\n   * _Example:_ Suppose you have a function, `startTestServer`, that returns a\n   * promise for when a server is ready for requests. You can block a WebDriver\n   * client on this promise with:\n   *\n   *     var started = startTestServer();\n   *     driver.wait(started, 5 * 1000, 'Server should start within 5 seconds');\n   *     driver.get(getServerUrl());\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} opt_timeout How long to wait for the condition to be true.\n   * @param {string=} opt_message An optional message to use if the wait times\n   *     out.\n   * @return {!(promise.Thenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     input condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(condition, opt_timeout, opt_message) {}\n\n  /**\n   * Schedules a command to make the driver sleep for the given amount of time.\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the sleep has finished.\n   */\n  sleep(ms) {}\n\n  /**\n   * Schedules a command to retrieve the current window handle.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Schedules a command to retrieve the current list of available window handles.\n   * @return {!promise.Thenable<!Array<string>>} A promise that will\n   *     be resolved with an array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Schedules a command to retrieve the current page's source. The page source\n   * returned is a representation of the underlying DOM: do not expect it to be\n   * formatted or escaped in the same way as the response sent from the web\n   * server.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Schedules a command to close the current window.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  close() {}\n\n  /**\n   * Schedules a command to navigate to the given URL.\n   * @param {string} url The fully qualified URL to open.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the document has finished loading.\n   */\n  get(url) {}\n\n  /**\n   * Schedules a command to retrieve the URL of the current page.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Schedules a command to retrieve the current page's title.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the current page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Schedule a command to find an element on the page. If the element cannot be\n   * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned\n   * by the driver. Unlike other commands, this error cannot be suppressed. In\n   * other words, scheduling a command to find an element doubles as an assert\n   * that the element is present on the page. To test whether an element is\n   * present on the page, use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {}\n\n  /**\n   * Schedule a command to search for multiple elements on the page.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A\n   *     promise that will resolve to an array of WebElements.\n   */\n  findElements(locator) {}\n\n  /**\n   * Schedule a command to take a screenshot. The driver makes a best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n}\n\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(Session|IThenable<!Session>)} session Either a known session or a\n   *     promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {promise.ControlFlow=} opt_flow The flow to\n   *     schedule commands through. Defaults to the active flow object.\n   * @param {(function(this: void): ?)=} opt_onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, opt_flow, opt_onQuit) {\n    /** @private {!promise.ControlFlow} */\n    this.flow_ = opt_flow || promise.controlFlow();\n\n    /** @private {!promise.Thenable<!Session>} */\n    this.session_ = this.flow_.promise(resolve => resolve(session));\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor;\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null;\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = opt_onQuit;\n  }\n\n  /**\n   * Creates a new WebDriver client for an existing session.\n   * @param {!command.Executor} executor Command executor to use when querying\n   *     for session details.\n   * @param {string} sessionId ID of the session to attach to.\n   * @param {promise.ControlFlow=} opt_flow The control flow all\n   *     driver commands should execute under. Defaults to the\n   *     {@link promise.controlFlow() currently active}  control flow.\n   * @return {!WebDriver} A new client for the specified session.\n   */\n  static attachToSession(executor, sessionId, opt_flow) {\n    let flow = opt_flow || promise.controlFlow();\n    let cmd = new command.Command(command.Name.DESCRIBE_SESSION)\n        .setParameter('sessionId', sessionId);\n    let session = flow.execute(\n        () => executeCommand(executor, cmd).catch(err => {\n          // The DESCRIBE_SESSION command is not supported by the W3C spec, so\n          // if we get back an unknown command, just return a session with\n          // unknown capabilities.\n          if (err instanceof error.UnknownCommandError) {\n            return new Session(sessionId, new Capabilities);\n          }\n          throw err;\n        }),\n        'WebDriver.attachToSession()');\n    return new WebDriver(session, executor, flow);\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * By default, the requested session `capabilities` are merely \"desired\" and\n   * the remote end will still create a new session even if it cannot satisfy\n   * all of the requested capabilities. You can query which capabilities a\n   * session actually has using the\n   * {@linkplain #getCapabilities() getCapabilities()} method on the returned\n   * WebDriver instance.\n   *\n   * To define _required capabilities_, provide the `capabilities` as an object\n   * literal with `required` and `desired` keys. The `desired` key may be\n   * omitted if all capabilities are required, and vice versa. If the server\n   * cannot create a session with all of the required capabilities, it will\n   * return an {@linkplain error.SessionNotCreatedError}.\n   *\n   *     let required = new Capabilities().set('browserName', 'firefox');\n   *     let desired = new Capabilities().set('version', '45');\n   *     let driver = WebDriver.createSession(executor, {required, desired});\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * It is recommended that this promise is left _unhandled_ so it will\n   * propagate through the {@linkplain promise.ControlFlow control flow} and\n   * cause subsequent commands to fail.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {(!Capabilities|\n   *          {desired: (Capabilities|undefined),\n   *           required: (Capabilities|undefined)})} capabilities The desired\n   *     capabilities for the new session.\n   * @param {promise.ControlFlow=} opt_flow The control flow all driver\n   *     commands should execute under, including the initial session creation.\n   *     Defaults to the {@link promise.controlFlow() currently active}\n   *     control flow.\n   * @param {(function(this: void): ?)=} opt_onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities, opt_flow, opt_onQuit) {\n    let flow = opt_flow || promise.controlFlow();\n    let cmd = new command.Command(command.Name.NEW_SESSION);\n\n    if (capabilities && (capabilities.desired || capabilities.required)) {\n      cmd.setParameter('desiredCapabilities', capabilities.desired);\n      cmd.setParameter('requiredCapabilities', capabilities.required);\n    } else {\n      cmd.setParameter('desiredCapabilities', capabilities);\n    }\n\n    let session = flow.execute(\n        () => executeCommand(executor, cmd),\n        'WebDriver.createSession()');\n    if (typeof opt_onQuit === 'function') {\n      session = session.catch(err => {\n        return Promise.resolve(opt_onQuit.call(void 0)).then(_ => {throw err;});\n      });\n    }\n    return new this(session, executor, flow, opt_onQuit);\n  }\n\n  /** @override */\n  controlFlow() {\n    return this.flow_;\n  }\n\n  /** @override */\n  schedule(command, description) {\n    command.setParameter('sessionId', this.session_);\n\n    // If any of the command parameters are rejected promises, those\n    // rejections may be reported as unhandled before the control flow\n    // attempts to execute the command. To ensure parameters errors\n    // propagate through the command itself, we resolve all of the\n    // command parameters now, but suppress any errors until the ControlFlow\n    // actually executes the command. This addresses scenarios like catching\n    // an element not found error in:\n    //\n    //     driver.findElement(By.id('foo')).click().catch(function(e) {\n    //       if (e instanceof NoSuchElementError) {\n    //         // Do something.\n    //       }\n    //     });\n    var prepCommand = toWireValue(command.getParameters());\n    prepCommand.catch(function() {});\n\n    var flow = this.flow_;\n    var executor = this.executor_;\n    return flow.execute(() => {\n      // Retrieve resolved command parameters; any previously suppressed errors\n      // will now propagate up through the control flow as part of the command\n      // execution.\n      return prepCommand.then(function(parameters) {\n        command.setParameters(parameters);\n        return executor.execute(command);\n      }).then(value => fromWireValue(this, value));\n    }, description);\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector;\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_;\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_;\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then(s => s.getCapabilities());\n  }\n\n  /** @override */\n  quit() {\n    var result = this.schedule(\n        new command.Command(command.Name.QUIT),\n        'WebDriver.quit()');\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return /** @type {!promise.Thenable} */(promise.finally(result, () => {\n      this.session_ = this.flow_.promise((_, reject) => {\n        reject(new error.NoSuchSessionError(\n            'This driver instance does not have a valid session ID ' +\n            '(did you call WebDriver.quit()?) and may no longer be used.'));\n      });\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function() {});\n\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0);\n      }\n    }));\n  }\n\n  /** @override */\n  actions() {\n    return new actions.ActionSequence(this);\n  }\n\n  /** @override */\n  touchActions() {\n    return new actions.TouchSequence(this);\n  }\n\n  /** @override */\n  executeScript(script, var_args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    let args =\n        arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];\n   return this.schedule(\n        new command.Command(command.Name.EXECUTE_SCRIPT).\n            setParameter('script', script).\n            setParameter('args', args),\n        'WebDriver.executeScript()');\n  }\n\n  /** @override */\n  executeAsyncScript(script, var_args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    let args = Array.prototype.slice.call(arguments, 1);\n    return this.schedule(\n        new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).\n            setParameter('script', script).\n            setParameter('args', args),\n        'WebDriver.executeScript()');\n  }\n\n  /** @override */\n  call(fn, opt_scope, var_args) {\n    let args = Array.prototype.slice.call(arguments, 2);\n    return this.flow_.execute(function() {\n      return promise.fullyResolved(args).then(function(args) {\n        if (promise.isGenerator(fn)) {\n          args.unshift(fn, opt_scope);\n          return promise.consume.apply(null, args);\n        }\n        return fn.apply(opt_scope, args);\n      });\n    }, 'WebDriver.call(' + (fn.name || 'function') + ')');\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    if (promise.isPromise(condition)) {\n      return this.flow_.wait(\n          /** @type {!IThenable} */(condition),\n          opt_timeout, opt_message);\n    }\n\n    var message = opt_message;\n    var fn = /** @type {!Function} */(condition);\n    if (condition instanceof Condition) {\n      message = message || condition.description();\n      fn = condition.fn;\n    }\n\n    if (typeof fn !== 'function') {\n      throw TypeError(\n          'Wait condition must be a promise-like object, function, or a '\n              + 'Condition object');\n    }\n\n    var driver = this;\n    var result = this.flow_.wait(function() {\n      if (promise.isGenerator(fn)) {\n        return promise.consume(fn, null, [driver]);\n      }\n      return fn(driver);\n    }, opt_timeout, message);\n\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(this, result.then(function(value) {\n        if (!(value instanceof WebElement)) {\n          throw TypeError(\n              'WebElementCondition did not resolve to a WebElement: '\n                  + Object.prototype.toString.call(value));\n        }\n        return value;\n      }));\n    }\n    return result;\n  }\n\n  /** @override */\n  sleep(ms) {\n    return this.flow_.timeout(ms, 'WebDriver.sleep(' + ms + ')');\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.schedule(\n        new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE),\n        'WebDriver.getWindowHandle()');\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.schedule(\n        new command.Command(command.Name.GET_WINDOW_HANDLES),\n        'WebDriver.getAllWindowHandles()');\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.schedule(\n        new command.Command(command.Name.GET_PAGE_SOURCE),\n        'WebDriver.getPageSource()');\n  }\n\n  /** @override */\n  close() {\n    return this.schedule(new command.Command(command.Name.CLOSE),\n                         'WebDriver.close()');\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url);\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.schedule(\n        new command.Command(command.Name.GET_CURRENT_URL),\n        'WebDriver.getCurrentUrl()');\n  }\n\n  /** @override */\n  getTitle() {\n    return this.schedule(new command.Command(command.Name.GET_TITLE),\n                         'WebDriver.getTitle()');\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id;\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      id = this.schedule(cmd, 'WebDriver.findElement(' + locator + ')');\n    }\n    return new WebElementPromise(this, id);\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search\n   *     context.\n   * @return {!promise.Thenable<!WebElement>} A\n   *     promise that will resolve to a list of WebElements.\n   * @private\n   */\n  findElementInternal_(locatorFn, context) {\n    return this.call(() => locatorFn(context)).then(function(result) {\n      if (Array.isArray(result)) {\n        result = result[0];\n      }\n      if (!(result instanceof WebElement)) {\n        throw new TypeError('Custom locator did not return a WebElement');\n      }\n      return result;\n    });\n  }\n\n  /** @override */\n  findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      return this.schedule(cmd, 'WebDriver.findElements(' + locator + ')')\n          .then(\n              (res) => Array.isArray(res) ? res : [],\n              (e) =>  {\n                if (e instanceof error.NoSuchElementError) {\n                  return [];\n                }\n                throw e;\n              });\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A promise that\n   *     will resolve to an array of WebElements.\n   * @private\n   */\n  findElementsInternal_(locatorFn, context) {\n    return this.call(() => locatorFn(context)).then(function(result) {\n      if (result instanceof WebElement) {\n        return [result];\n      }\n\n      if (!Array.isArray(result)) {\n        return [];\n      }\n\n      return result.filter(function(item) {\n        return item instanceof WebElement;\n      });\n    });\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.schedule(new command.Command(command.Name.SCREENSHOT),\n        'WebDriver.takeScreenshot()');\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this);\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this);\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this);\n  }\n}\n\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Schedules a command to navigate to a new URL.\n   * @param {string} url The URL to navigate to.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the URL has been loaded.\n   */\n  to(url) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET).\n            setParameter('url', url),\n        'WebDriver.navigate().to(' + url + ')');\n  }\n\n  /**\n   * Schedules a command to move backwards in the browser history.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n  back() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GO_BACK),\n        'WebDriver.navigate().back()');\n  }\n\n  /**\n   * Schedules a command to move forwards in the browser history.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n  forward() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GO_FORWARD),\n        'WebDriver.navigate().forward()');\n  }\n\n  /**\n   * Schedules a command to refresh the current page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.REFRESH),\n        'WebDriver.navigate().refresh()');\n  }\n}\n\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Schedules a command to add a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie({name, value, path, domain, secure, httpOnly, expiry}) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError(\n          'Invalid cookie name \"' + name + '\"');\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError(\n          'Invalid cookie value \"' + value + '\"');\n    }\n\n    let cookieString = name + '=' + value +\n        (domain ? ';domain=' + domain : '') +\n        (path ? ';path=' + path : '') +\n        (secure ? ';secure' : '');\n\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry);\n      cookieString += ';expires=' + new Date(expiry * 1000).toUTCString();\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */(expiry);\n      expiry = Math.floor(date.getTime() / 1000);\n      cookieString += ';expires=' + date.toUTCString();\n    }\n\n    return this.driver_.schedule(\n        new command.Command(command.Name.ADD_COOKIE).\n            setParameter('cookie', {\n              'name': name,\n              'value': value,\n              'path': path,\n              'domain': domain,\n              'secure': !!secure,\n              'httpOnly': !!httpOnly,\n              'expiry': expiry\n            }),\n        'WebDriver.manage().addCookie(' + cookieString + ')');\n  }\n\n  /**\n   * Schedules a command to delete all cookies visible to the current page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.DELETE_ALL_COOKIES),\n        'WebDriver.manage().deleteAllCookies()');\n  }\n\n  /**\n   * Schedules a command to delete the cookie with the given name. This command\n   * is a no-op if there is no cookie with the given name visible to the current\n   * page.\n   * @param {string} name The name of the cookie to delete.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.DELETE_COOKIE).\n            setParameter('name', name),\n        'WebDriver.manage().deleteCookie(' + name + ')');\n  }\n\n  /**\n   * Schedules a command to retrieve all cookies visible to the current page.\n   * Each cookie will be returned as a JSON object as described by the WebDriver\n   * wire protocol.\n   * @return {!promise.Thenable<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET_ALL_COOKIES),\n        'WebDriver.manage().getCookies()');\n  }\n\n  /**\n   * Schedules a command to retrieve the cookie with the given name. Returns null\n   * if there is no such cookie. The cookie will be returned as a JSON object as\n   * described by the WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!promise.Thenable<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie, or `null` if there is no such cookie.\n   */\n  getCookie(name) {\n    return this.getCookies().then(function(cookies) {\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie;\n        }\n      }\n      return null;\n    });\n  }\n\n  /**\n   * Schedules a command to fetch the timeouts currently configured for the\n   * current session.\n   *\n   * @return {!promise.Thenable<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET_TIMEOUT),\n        `WebDriver.manage().getTimeouts()`)\n  }\n\n  /**\n   * Schedules a command to set timeout durations associated with the current\n   * session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!promise.Thenable<void>} A promise that will be resolved when the\n   *     timeouts have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts({script, pageLoad, implicit} = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT);\n\n    let valid = false;\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true;\n        cmd.setParameter(key, value);\n      } else if (typeof value !== 'undefined') {\n        throw TypeError(\n            'invalid timeouts configuration:'\n                + ` expected \"${key}\" to be a number, got ${typeof value}`);\n      }\n    }\n    setParam('implicit', implicit);\n    setParam('pageLoad', pageLoad);\n    setParam('script', script);\n\n    if (valid) {\n      return this.driver_.schedule(cmd, `WebDriver.manage().setTimeouts()`)\n          .catch(() => {\n            // Fallback to the legacy method.\n            let cmds = [];\n            if (typeof script === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'script', script));\n            }\n            if (typeof implicit === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'implicit', implicit));\n            }\n            if (typeof pageLoad === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad));\n            }\n            return Promise.all(cmds);\n          });\n    }\n    throw TypeError('no timeouts specified');\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver\n   *     logs.\n   */\n  logs() {\n    return new Logs(this.driver_);\n  }\n\n  /**\n   * @return {!Timeouts} The interface for managing driver timeouts.\n   * @deprecated Use {@link #setTimeouts()} instead.\n   */\n  timeouts() {\n    return new Timeouts(this.driver_);\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_);\n  }\n}\n\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!promise.Thenable<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.schedule(\n      new command.Command(command.Name.SET_TIMEOUT)\n          .setParameter('type', type)\n          .setParameter('ms', ms),\n      `WebDriver.manage().setTimeouts({${type}: ${ms}})`);\n}\n\n\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function() {};\n\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name;\n\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value;\n\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path;\n\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain;\n\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure;\n\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly;\n\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry;\n\n\n/**\n * An interface for managing timeout behavior for WebDriver instances.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().timeouts()\n *\n * @deprecated This has been deprecated in favor of\n *     {@link Options#setTimeouts()}, which supports setting multiple timeouts\n *     at once.\n * @see WebDriver#manage()\n * @see Options#timeouts()\n */\nclass Timeouts {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Specifies the amount of time the driver should wait when searching for an\n   * element if it is not immediately present.\n   *\n   * When searching for a single element, the driver should poll the page\n   * until the element has been found, or this timeout expires before failing\n   * with a {@link bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching\n   * for multiple elements, the driver should poll the page until at least one\n   * element has been found or this timeout has expired.\n   *\n   * Setting the wait timeout to 0 (its default value), disables implicit\n   * waiting.\n   *\n   * Increasing the implicit wait timeout should be used judiciously as it\n   * will have an adverse effect on test run time, especially when used with\n   * slower location strategies like XPath.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the implicit wait timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({implicit: ms})}.\n   */\n  implicitlyWait(ms) {\n    return this.driver_.manage().setTimeouts({implicit: ms});\n  }\n\n  /**\n   * Sets the amount of time to wait, in milliseconds, for an asynchronous\n   * script to finish execution before returning an error. If the timeout is\n   * less than or equal to 0, the script will be allowed to run indefinitely.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the script timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({script: ms})}.\n   */\n  setScriptTimeout(ms) {\n    return this.driver_.manage().setTimeouts({script: ms});\n  }\n\n  /**\n   * Sets the amount of time to wait for a page load to complete before\n   * returning an error.  If the timeout is negative, page loads may be\n   * indefinite.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the timeout has been set.\n   * @deprecated Use {@link Options#setTimeouts()\n   *     driver.manage().setTimeouts({pageLoad: ms})}.\n   */\n  pageLoadTimeout(ms) {\n    return this.driver_.manage().setTimeouts({pageLoad: ms});\n  }\n}\n\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Retrieves the window's current position, relative to the top left corner of\n   * the screen.\n   * @return {!promise.Thenable<{x: number, y: number}>} A promise\n   *     that will be resolved with the window's position in the form of a\n   *     {x:number, y:number} object literal.\n   */\n  getPosition() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET_WINDOW_POSITION).\n            setParameter('windowHandle', 'current'),\n        'WebDriver.manage().window().getPosition()');\n  }\n\n  /**\n   * Repositions the current window.\n   * @param {number} x The desired horizontal position, relative to the left\n   *     side of the screen.\n   * @param {number} y The desired vertical position, relative to the top of the\n   *     of the screen.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n  setPosition(x, y) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SET_WINDOW_POSITION).\n            setParameter('windowHandle', 'current').\n            setParameter('x', x).\n            setParameter('y', y),\n        'WebDriver.manage().window().setPosition(' + x + ', ' + y + ')');\n  }\n\n  /**\n   * Retrieves the window's current size.\n   * @return {!promise.Thenable<{width: number, height: number}>} A\n   *     promise that will be resolved with the window's size in the form of a\n   *     {width:number, height:number} object literal.\n   */\n  getSize() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET_WINDOW_SIZE).\n            setParameter('windowHandle', 'current'),\n        'WebDriver.manage().window().getSize()');\n  }\n\n  /**\n   * Resizes the current window.\n   * @param {number} width The desired window width.\n   * @param {number} height The desired window height.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n  setSize(width, height) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SET_WINDOW_SIZE).\n            setParameter('windowHandle', 'current').\n            setParameter('width', width).\n            setParameter('height', height),\n        'WebDriver.manage().window().setSize(' + width + ', ' + height + ')');\n  }\n\n  /**\n   * Maximizes the current window.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the command has completed.\n   */\n  maximize() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.MAXIMIZE_WINDOW).\n            setParameter('windowHandle', 'current'),\n        'WebDriver.manage().window().maximize()');\n  }\n}\n\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!promise.Thenable<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).\n        setParameter('type', type);\n    return this.driver_.schedule(\n        cmd, 'WebDriver.manage().logs().get(' + type + ')').\n        then(function(entries) {\n          return entries.map(function(entry) {\n            if (!(entry instanceof logging.Entry)) {\n              return new logging.Entry(\n                  entry['level'], entry['message'], entry['timestamp'],\n                  entry['type']);\n            }\n            return entry;\n          });\n        });\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!promise.Thenable<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES),\n        'WebDriver.manage().logs().getAvailableLogTypes()');\n  }\n}\n\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Schedules a command retrieve the {@code document.activeElement} element on\n   * the current document, or {@code document.body} if activeElement is not\n   * available.\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    var id = this.driver_.schedule(\n        new command.Command(command.Name.GET_ACTIVE_ELEMENT),\n        'WebDriver.switchTo().activeElement()');\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Schedules a command to switch focus of all future commands to the topmost\n   * frame on the page.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SWITCH_TO_FRAME).\n            setParameter('id', null),\n        'WebDriver.switchTo().defaultContent()');\n  }\n\n  /**\n   * Schedules a command to switch the focus of all future commands to another\n   * frame on the page. The target frame may be specified as one of the\n   * following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|WebElement|null)} id The frame locator.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SWITCH_TO_FRAME).\n            setParameter('id', id),\n        'WebDriver.switchTo().frame(' + id + ')');\n  }\n\n  /**\n   * Schedules a command to switch the focus of all future commands to another\n   * window. Windows may be specified by their {@code window.name} attribute or\n   * by its handle (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SWITCH_TO_WINDOW).\n            // \"name\" supports the legacy drivers. \"handle\" is the W3C\n            // compliant parameter.\n            setParameter('name', nameOrHandle).\n            setParameter('handle', nameOrHandle),\n        'WebDriver.switchTo().window(' + nameOrHandle + ')');\n  }\n\n  /**\n   * Schedules a command to change focus to the active modal dialog, such as\n   * those opened by `window.alert()`, `window.confirm()`, and\n   * `window.prompt()`. The returned promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    var text = this.driver_.schedule(\n        new command.Command(command.Name.GET_ALERT_TEXT),\n        'WebDriver.switchTo().alert()');\n    var driver = this.driver_;\n    return new AlertPromise(driver, text.then(function(text) {\n      return new Alert(driver, text);\n    }));\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\n\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!promise.Thenable<string>} */\n    this.id_ = driver.controlFlow().promise(resolve => resolve(id));\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} opt_noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id, opt_noLegacy) {\n    return opt_noLegacy\n        ? {[ELEMENT_ID_KEY]: id}\n        : {[ELEMENT_ID_KEY]: id, [LEGACY_ELEMENT_ID_KEY]: id};\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[ELEMENT_ID_KEY] === 'string') {\n        return obj[ELEMENT_ID_KEY];\n      } else if (typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string') {\n        return obj[LEGACY_ELEMENT_ID_KEY];\n      }\n    }\n    throw new TypeError('object is not a WebElement ID');\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return obj && typeof obj === 'object'\n        && (typeof obj[ELEMENT_ID_KEY] === 'string'\n            || typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string');\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static equals(a, b) {\n    if (a === b) {\n      return a.driver_.controlFlow().promise(resolve => resolve(true));\n    }\n    let ids = [a.getId(), b.getId()];\n    return promise.all(ids).then(function(ids) {\n      // If the two element's have the same ID, they should be considered\n      // equal. Otherwise, they may still be equivalent, but we'll need to\n      // ask the server to check for us.\n      if (ids[0] === ids[1]) {\n        return true;\n      }\n\n      let cmd = new command.Command(command.Name.ELEMENT_EQUALS);\n      cmd.setParameter('id', ids[0]);\n      cmd.setParameter('other', ids[1]);\n      return a.driver_.schedule(cmd, 'WebElement.equals()');\n    });\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_;\n  }\n\n  /**\n   * @return {!promise.Thenable<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId);\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @param {string} description A description of the command for debugging.\n   * @return {!promise.Thenable<T>} A promise that will be resolved\n   *     with the command result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  schedule_(command, description) {\n    command.setParameter('id', this);\n    return this.driver_.schedule(command, description);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(\n          command.Name.FIND_CHILD_ELEMENT).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      id = this.schedule_(cmd, 'WebElement.findElement(' + locator + ')');\n    }\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Schedules a command to find all of the descendants of this element that\n   * match the given search criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!promise.Thenable<!Array<!WebElement>>} A\n   *     promise that will resolve to an array of WebElements.\n   */\n  findElements(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      var cmd = new command.Command(\n          command.Name.FIND_CHILD_ELEMENTS).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      return this.schedule_(cmd, 'WebElement.findElements(' + locator + ')')\n          .then(result => Array.isArray(result) ? result : []);\n    }\n  }\n\n  /**\n   * Schedules a command to click on this element.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the click command has completed.\n   */\n  click() {\n    return this.schedule_(\n        new command.Command(command.Name.CLICK_ELEMENT),\n        'WebElement.click()');\n  }\n\n  /**\n   * Schedules a command to type a sequence on the DOM element represented by\n   * this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} var_args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when all keys have been typed.\n   */\n  sendKeys(var_args) {\n    let keys = Promise.all(Array.prototype.slice.call(arguments, 0)).\n        then(keys => {\n          let ret = [];\n          keys.forEach(key => {\n            let type = typeof key;\n            if (type === 'number') {\n              key = String(key);\n            } else if (type !== 'string') {\n              throw TypeError(\n                  'each key must be a number of string; got ' + type);\n            }\n\n            // The W3C protocol requires keys to be specified as an array where\n            // each element is a single key.\n            ret.push.apply(ret, key.split(''));\n          });\n          return ret;\n        });\n\n    if (!this.driver_.fileDetector_) {\n      return this.schedule_(\n          new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).\n              setParameter('text', keys.then(keys => keys.join(''))).\n              setParameter('value', keys),\n          'WebElement.sendKeys()');\n    }\n\n    // Suppress unhandled rejection errors until the flow executes the command.\n    keys.catch(function() {});\n\n    var element = this;\n    return this.getDriver().controlFlow().execute(function() {\n      return keys.then(function(keys) {\n        return element.driver_.fileDetector_\n            .handleFile(element.driver_, keys.join(''));\n      }).then(function(keys) {\n        return element.schedule_(\n            new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).\n                setParameter('text', keys).\n                setParameter('value', keys.split('')),\n            'WebElement.sendKeys()');\n      });\n    }, 'WebElement.sendKeys()');\n  }\n\n  /**\n   * Schedules a command to query for the tag/node name of this element.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the element's tag name.\n   */\n  getTagName() {\n    return this.schedule_(\n        new command.Command(command.Name.GET_ELEMENT_TAG_NAME),\n        'WebElement.getTagName()');\n  }\n\n  /**\n   * Schedules a command to query for the computed style of the element\n   * represented by this instance. If the element inherits the named style from\n   * its parent, the parent will be queried for its value.  Where possible, color\n   * values will be converted to their hex representation (e.g. #00ff00 instead\n   * of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    var name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n    return this.schedule_(\n        new command.Command(name).\n            setParameter('propertyName', cssStyleProperty),\n        'WebElement.getCssValue(' + cssStyleProperty + ')');\n  }\n\n  /**\n   * Schedules a command to query for the value of the given attribute of the\n   * element. Will return the current value, even if it has been modified after\n   * the page has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semi-colon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!promise.Thenable<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.schedule_(\n        new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).\n            setParameter('name', attributeName),\n        'WebElement.getAttribute(' + attributeName + ')');\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.schedule_(\n        new command.Command(command.Name.GET_ELEMENT_TEXT),\n        'WebElement.getText()');\n  }\n\n  /**\n   * Schedules a command to compute the size of this element's bounding box, in\n   * pixels.\n   * @return {!promise.Thenable<{width: number, height: number}>} A\n   *     promise that will be resolved with the element's size as a\n   *     {@code {width:number, height:number}} object.\n   */\n  getSize() {\n    return this.schedule_(\n        new command.Command(command.Name.GET_ELEMENT_SIZE),\n        'WebElement.getSize()');\n  }\n\n  /**\n   * Schedules a command to compute the location of this element in page space.\n   * @return {!promise.Thenable<{x: number, y: number}>} A promise that\n   *     will be resolved to the element's location as a\n   *     {@code {x:number, y:number}} object.\n   */\n  getLocation() {\n    return this.schedule_(\n        new command.Command(command.Name.GET_ELEMENT_LOCATION),\n        'WebElement.getLocation()');\n  }\n\n  /**\n   * Schedules a command to query whether the DOM element represented by this\n   * instance is enabled, as dictated by the {@code disabled} attribute.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.schedule_(\n        new command.Command(command.Name.IS_ELEMENT_ENABLED),\n        'WebElement.isEnabled()');\n  }\n\n  /**\n   * Schedules a command to query whether this element is selected.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.schedule_(\n        new command.Command(command.Name.IS_ELEMENT_SELECTED),\n        'WebElement.isSelected()');\n  }\n\n  /**\n   * Schedules a command to submit the form containing this element (or this\n   * element if it is a FORM element). This command is a no-op if the element is\n   * not contained in a form.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    return this.schedule_(\n        new command.Command(command.Name.SUBMIT_ELEMENT),\n        'WebElement.submit()');\n  }\n\n  /**\n   * Schedules a command to clear the `value` of this element. This command has\n   * no effect if the underlying DOM element is neither a text INPUT element\n   * nor a TEXTAREA element.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.schedule_(\n        new command.Command(command.Name.CLEAR_ELEMENT),\n        'WebElement.clear()');\n  }\n\n  /**\n   * Schedules a command to test whether this element is currently displayed.\n   * @return {!promise.Thenable<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.schedule_(\n        new command.Command(command.Name.IS_ELEMENT_DISPLAYED),\n        'WebElement.isDisplayed()');\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @param {boolean=} opt_scroll Optional argument that indicates whether the\n   *     element should be scrolled into view before taking a screenshot.\n   *     Defaults to false.\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot(opt_scroll) {\n    var scroll = !!opt_scroll;\n    return this.schedule_(\n        new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT)\n            .setParameter('scroll', scroll),\n        'WebElement.takeScreenshot(' + scroll + ')');\n  }\n}\n\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {promise.CancellableThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!promise.Thenable<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused');\n\n    /**\n     * Cancel operation is only supported if the wrapped thenable is also\n     * cancellable.\n     * @param {(string|Error)=} opt_reason\n     * @override\n     */\n    this.cancel = function(opt_reason) {\n      if (promise.CancellableThenable.isImplementation(el)) {\n        /** @type {!promise.CancellableThenable} */(el).cancel(opt_reason);\n      }\n    };\n\n    /** @override */\n    this.then = el.then.bind(el);\n\n    /** @override */\n    this.catch = el.catch.bind(el);\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function() {\n      return el.then(function(el) {\n        return el.getId();\n      });\n    };\n  }\n}\npromise.CancellableThenable.addImplementation(WebElementPromise);\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!promise.Thenable<string>} */\n    this.text_ = driver.controlFlow().promise(resolve => resolve(text));\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!promise.Thenable<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Sets the username and password in an alert prompting for credentials (such\n   * as a Basic HTTP Auth prompt). This method will implicitly\n   * {@linkplain #accept() submit} the dialog.\n   *\n   * @param {string} username The username to send.\n   * @param {string} password The password to send.\n   * @return {!promise.Thenable<void>} A promise that will be resolved when this\n   *     command has completed.\n   */\n  authenticateAs(username, password) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SET_ALERT_CREDENTIALS),\n        'WebDriver.switchTo().alert()'\n            + `.authenticateAs(\"${username}\", \"${password}\")`);\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.ACCEPT_ALERT),\n        'WebDriver.switchTo().alert().accept()');\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.schedule(\n        new command.Command(command.Name.DISMISS_ALERT),\n        'WebDriver.switchTo().alert().dismiss()');\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.schedule(\n        new command.Command(command.Name.SET_ALERT_TEXT).\n            setParameter('text', text),\n        'WebDriver.switchTo().alert().sendKeys(' + text + ')');\n  }\n}\n\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {promise.CancellableThenable<!webdriver.Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!promise.Thenable<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused');\n\n    /**\n     * Cancel operation is only supported if the wrapped thenable is also\n     * cancellable.\n     * @param {(string|Error)=} opt_reason\n     * @override\n     */\n    this.cancel = function(opt_reason) {\n      if (promise.CancellableThenable.isImplementation(alert)) {\n        /** @type {!promise.CancellableThenable} */(alert).cancel(opt_reason);\n      }\n    };\n\n    /** @override */\n    this.then = alert.then.bind(alert);\n\n    /** @override */\n    this.catch = alert.catch.bind(alert);\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function() {\n      return alert.then(function(alert) {\n        return alert.getText();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.authenticateAs = function(username, password) {\n      return alert.then(function(alert) {\n        return alert.authenticateAs(username, password);\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function() {\n      return alert.then(function(alert) {\n        return alert.accept();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function() {\n      return alert.then(function(alert) {\n        return alert.dismiss();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function(text) {\n      return alert.then(function(alert) {\n        return alert.sendKeys(text);\n      });\n    };\n  }\n}\npromise.CancellableThenable.addImplementation(AlertPromise);\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Alert: Alert,\n  AlertPromise: AlertPromise,\n  Condition: Condition,\n  Logs: Logs,\n  Navigation: Navigation,\n  Options: Options,\n  TargetLocator: TargetLocator,\n  Timeouts: Timeouts,\n  IWebDriver: IWebDriver,\n  WebDriver: WebDriver,\n  WebElement: WebElement,\n  WebElementCondition: WebElementCondition,\n  WebElementPromise: WebElementPromise,\n  Window: Window\n};\n"]},"metadata":{},"sourceType":"script"}