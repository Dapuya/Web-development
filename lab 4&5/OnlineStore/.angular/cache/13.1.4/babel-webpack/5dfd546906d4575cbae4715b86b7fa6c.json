{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Profile management module. This module is considered internal;\n * users should use {@link selenium-webdriver/firefox}.\n */\n'use strict';\n\nconst fs = require('fs'),\n      path = require('path'),\n      vm = require('vm');\n\nconst isDevMode = require('../lib/devmode'),\n      Symbols = require('../lib/symbols'),\n      io = require('../io'),\n      {\n  Zip,\n  unzip\n} = require('../io/zip'),\n      extension = require('./extension');\n/**\n * Parses a user.js file in a Firefox profile directory.\n * @param {string} f Path to the file to parse.\n * @return {!Promise<!Object>} A promise for the parsed preferences as\n *     a JSON object. If the file does not exist, an empty object will be\n *     returned.\n */\n\n\nfunction loadUserPrefs(f) {\n  return io.read(f).then(function onSuccess(contents) {\n    var prefs = {};\n    var context = vm.createContext({\n      'user_pref': function (key, value) {\n        prefs[key] = value;\n      }\n    });\n    vm.runInContext(contents.toString(), context, f);\n    return prefs;\n  }, function onError(err) {\n    if (err && err.code === 'ENOENT') {\n      return {};\n    }\n\n    throw err;\n  });\n}\n/**\n * @param {!Object} prefs The default preferences to write. Will be\n *     overridden by user.js preferences in the template directory and the\n *     frozen preferences required by WebDriver.\n * @param {string} dir Path to the directory write the file to.\n * @return {!Promise<string>} A promise for the profile directory,\n *     to be fulfilled when user preferences have been written.\n */\n\n\nfunction writeUserPrefs(prefs, dir) {\n  var userPrefs = path.join(dir, 'user.js');\n  return loadUserPrefs(userPrefs).then(function (overrides) {\n    Object.assign(prefs, overrides);\n    let keys = Object.keys(prefs);\n\n    if (!keys.length) {\n      return dir;\n    }\n\n    let contents = Object.keys(prefs).map(function (key) {\n      return 'user_pref(' + JSON.stringify(key) + ', ' + JSON.stringify(prefs[key]) + ');';\n    }).join('\\n');\n    return new Promise((resolve, reject) => {\n      fs.writeFile(userPrefs, contents, function (err) {\n        err && reject(err) || resolve(dir);\n      });\n    });\n  });\n}\n\n;\n/**\n * Installs a group of extensions in the given profile directory. If the\n * WebDriver extension is not included in this set, the default version\n * bundled with this package will be installed.\n * @param {!Array.<string>} extensions The extensions to install, as a\n *     path to an unpacked extension directory or a path to a xpi file.\n * @param {string} dir The profile directory to install to.\n * @return {!Promise<string>} A promise for the main profile directory\n *     once all extensions have been installed.\n */\n\nfunction installExtensions(extensions, dir) {\n  var next = 0;\n  var extensionDir = path.join(dir, 'extensions');\n  return new Promise(function (fulfill, reject) {\n    io.mkdir(extensionDir).then(installNext, reject);\n\n    function installNext() {\n      if (next >= extensions.length) {\n        fulfill(dir);\n      } else {\n        install(extensions[next++]);\n      }\n    }\n\n    function install(ext) {\n      extension.install(ext, extensionDir).then(function (id) {\n        installNext();\n      }, reject);\n    }\n  });\n}\n/**\n * Models a Firefox profile directory for use with the FirefoxDriver. The\n * {@code Profile} directory uses an in-memory model until\n * {@link #writeToDisk} or {@link #encode} is called.\n */\n\n\nclass Profile {\n  /**\n   * @param {string=} opt_dir Path to an existing Firefox profile directory to\n   *     use a template for this profile. If not specified, a blank profile will\n   *     be used.\n   */\n  constructor(opt_dir) {\n    /** @private {!Object} */\n    this.preferences_ = {};\n    /** @private {(string|undefined)} */\n\n    this.template_ = opt_dir;\n    /** @private {!Array<string>} */\n\n    this.extensions_ = [];\n  }\n  /**\n   * @return {(string|undefined)} Path to an existing Firefox profile directory\n   *     to use as a template when writing this Profile to disk.\n   */\n\n\n  getTemplateDir() {\n    return this.template_;\n  }\n  /**\n   * Registers an extension to be included with this profile.\n   * @param {string} extension Path to the extension to include, as either an\n   *     unpacked extension directory or the path to a xpi file.\n   */\n\n\n  addExtension(extension) {\n    this.extensions_.push(extension);\n  }\n  /**\n   * @return {!Array<string>} A list of extensions to install in this profile.\n   */\n\n\n  getExtensions() {\n    return this.extensions_;\n  }\n  /**\n   * Sets a desired preference for this profile.\n   * @param {string} key The preference key.\n   * @param {(string|number|boolean)} value The preference value.\n   * @throws {Error} If attempting to set a frozen preference.\n   */\n\n\n  setPreference(key, value) {\n    this.preferences_[key] = value;\n  }\n  /**\n   * Returns the currently configured value of a profile preference. This does\n   * not include any defaults defined in the profile's template directory user.js\n   * file (if a template were specified on construction).\n   * @param {string} key The desired preference.\n   * @return {(string|number|boolean|undefined)} The current value of the\n   *     requested preference.\n   */\n\n\n  getPreference(key) {\n    return this.preferences_[key];\n  }\n  /**\n   * @return {!Object} A copy of all currently configured preferences.\n   */\n\n\n  getPreferences() {\n    return Object.assign({}, this.preferences_);\n  }\n  /**\n   * Specifies which host the driver should listen for commands on. If not\n   * specified, the driver will default to \"localhost\". This option should be\n   * specified when \"localhost\" is not mapped to the loopback address\n   * (127.0.0.1) in `/etc/hosts`.\n   *\n   * @param {string} host the host the driver should listen for commands on\n   */\n\n\n  setHost(host) {\n    this.preferences_['webdriver_firefox_allowed_hosts'] = host;\n  }\n  /**\n   * @return {boolean} Whether the FirefoxDriver is configured to automatically\n   *     accept untrusted SSL certificates.\n   */\n\n\n  acceptUntrustedCerts() {\n    return !!this.preferences_['webdriver_accept_untrusted_certs'];\n  }\n  /**\n   * Sets whether the FirefoxDriver should automatically accept untrusted SSL\n   * certificates.\n   * @param {boolean} value .\n   */\n\n\n  setAcceptUntrustedCerts(value) {\n    this.preferences_['webdriver_accept_untrusted_certs'] = !!value;\n  }\n  /**\n   * Sets whether to assume untrusted certificates come from untrusted issuers.\n   * @param {boolean} value .\n   */\n\n\n  setAssumeUntrustedCertIssuer(value) {\n    this.preferences_['webdriver_assume_untrusted_issuer'] = !!value;\n  }\n  /**\n   * @return {boolean} Whether to assume untrusted certs come from untrusted\n   *     issuers.\n   */\n\n\n  assumeUntrustedCertIssuer() {\n    return !!this.preferences_['webdriver_assume_untrusted_issuer'];\n  }\n  /**\n   * Writes this profile to disk.\n   * @return {!Promise<string>} A promise for the path to the new profile\n   *     directory.\n   */\n\n\n  writeToDisk() {\n    var profileDir = io.tmpDir();\n\n    if (this.template_) {\n      profileDir = profileDir.then(function (dir) {\n        return io.copyDir(\n        /** @type {string} */\n        this.template_, dir, /(parent\\.lock|lock|\\.parentlock)/);\n      }.bind(this));\n    } // Freeze preferences for async operations.\n\n\n    let prefs = Object.assign({}, this.preferences_); // Freeze extensions for async operations.\n\n    var extensions = this.extensions_.concat();\n    return profileDir.then(function (dir) {\n      return writeUserPrefs(prefs, dir);\n    }).then(function (dir) {\n      return installExtensions(extensions, dir);\n    });\n  }\n  /**\n   * Write profile to disk, compress its containing directory, and return\n   * it as a Base64 encoded string.\n   *\n   * @return {!Promise<string>} A promise for the encoded profile as\n   *     Base64 string.\n   *\n   */\n\n\n  encode() {\n    return this.writeToDisk().then(function (dir) {\n      let zip = new Zip();\n      return zip.addDir(dir).then(() => zip.toBuffer()).then(buf => buf.toString('base64'));\n    });\n  }\n  /**\n   * Encodes this profile as a zipped, base64 encoded directory.\n   * @return {!Promise<string>} A promise for the encoded profile.\n   */\n\n\n  [Symbols.serialize]() {\n    return this.encode();\n  }\n\n} // PUBLIC API\n\n\nexports.Profile = Profile;\nexports.loadUserPrefs = loadUserPrefs;","map":{"version":3,"sources":["/Users/dariya/Documents/GitHub/Web-development/lab 4&5/wgg87w--run/node_modules/selenium-webdriver/firefox/profile.js"],"names":["fs","require","path","vm","isDevMode","Symbols","io","Zip","unzip","extension","loadUserPrefs","f","read","then","onSuccess","contents","prefs","context","createContext","key","value","runInContext","toString","onError","err","code","writeUserPrefs","dir","userPrefs","join","overrides","Object","assign","keys","length","map","JSON","stringify","Promise","resolve","reject","writeFile","installExtensions","extensions","next","extensionDir","fulfill","mkdir","installNext","install","ext","id","Profile","constructor","opt_dir","preferences_","template_","extensions_","getTemplateDir","addExtension","push","getExtensions","setPreference","getPreference","getPreferences","setHost","host","acceptUntrustedCerts","setAcceptUntrustedCerts","setAssumeUntrustedCertIssuer","assumeUntrustedCertIssuer","writeToDisk","profileDir","tmpDir","copyDir","bind","concat","encode","zip","addDir","toBuffer","buf","serialize","exports"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Profile management module. This module is considered internal;\n * users should use {@link selenium-webdriver/firefox}.\n */\n\n'use strict';\n\nconst fs = require('fs'),\n    path = require('path'),\n    vm = require('vm');\n\nconst isDevMode = require('../lib/devmode'),\n    Symbols = require('../lib/symbols'),\n    io = require('../io'),\n    {Zip, unzip} = require('../io/zip'),\n    extension = require('./extension');\n\n\n/**\n * Parses a user.js file in a Firefox profile directory.\n * @param {string} f Path to the file to parse.\n * @return {!Promise<!Object>} A promise for the parsed preferences as\n *     a JSON object. If the file does not exist, an empty object will be\n *     returned.\n */\nfunction loadUserPrefs(f) {\n  return io.read(f).then(\n      function onSuccess(contents) {\n        var prefs = {};\n        var context = vm.createContext({\n          'user_pref': function(key, value) {\n            prefs[key] = value;\n          }\n        });\n        vm.runInContext(contents.toString(), context, f);\n        return prefs;\n      },\n      function onError(err) {\n        if (err && err.code === 'ENOENT') {\n          return {};\n        }\n        throw err;\n      });\n}\n\n\n\n/**\n * @param {!Object} prefs The default preferences to write. Will be\n *     overridden by user.js preferences in the template directory and the\n *     frozen preferences required by WebDriver.\n * @param {string} dir Path to the directory write the file to.\n * @return {!Promise<string>} A promise for the profile directory,\n *     to be fulfilled when user preferences have been written.\n */\nfunction writeUserPrefs(prefs, dir) {\n  var userPrefs = path.join(dir, 'user.js');\n  return loadUserPrefs(userPrefs).then(function(overrides) {\n    Object.assign(prefs, overrides);\n\n    let keys = Object.keys(prefs);\n    if (!keys.length) {\n      return dir;\n    }\n\n    let contents = Object.keys(prefs).map(function(key) {\n      return 'user_pref(' + JSON.stringify(key) + ', ' +\n          JSON.stringify(prefs[key]) + ');';\n    }).join('\\n');\n\n    return new Promise((resolve, reject) => {\n      fs.writeFile(userPrefs, contents, function(err) {\n        err && reject(err) || resolve(dir);\n      });\n    });\n  });\n};\n\n\n/**\n * Installs a group of extensions in the given profile directory. If the\n * WebDriver extension is not included in this set, the default version\n * bundled with this package will be installed.\n * @param {!Array.<string>} extensions The extensions to install, as a\n *     path to an unpacked extension directory or a path to a xpi file.\n * @param {string} dir The profile directory to install to.\n * @return {!Promise<string>} A promise for the main profile directory\n *     once all extensions have been installed.\n */\nfunction installExtensions(extensions, dir) {\n  var next = 0;\n  var extensionDir = path.join(dir, 'extensions');\n\n  return new Promise(function(fulfill, reject) {\n    io.mkdir(extensionDir).then(installNext, reject);\n\n    function installNext() {\n      if (next >= extensions.length) {\n        fulfill(dir);\n      } else {\n        install(extensions[next++]);\n      }\n    }\n\n    function install(ext) {\n      extension.install(ext, extensionDir).then(function(id) {\n        installNext();\n      }, reject);\n    }\n  });\n}\n\n\n\n/**\n * Models a Firefox profile directory for use with the FirefoxDriver. The\n * {@code Profile} directory uses an in-memory model until\n * {@link #writeToDisk} or {@link #encode} is called.\n */\nclass Profile {\n  /**\n   * @param {string=} opt_dir Path to an existing Firefox profile directory to\n   *     use a template for this profile. If not specified, a blank profile will\n   *     be used.\n   */\n  constructor(opt_dir) {\n    /** @private {!Object} */\n    this.preferences_ = {};\n\n    /** @private {(string|undefined)} */\n    this.template_ = opt_dir;\n\n    /** @private {!Array<string>} */\n    this.extensions_ = [];\n  }\n\n  /**\n   * @return {(string|undefined)} Path to an existing Firefox profile directory\n   *     to use as a template when writing this Profile to disk.\n   */\n  getTemplateDir() {\n    return this.template_;\n  }\n\n  /**\n   * Registers an extension to be included with this profile.\n   * @param {string} extension Path to the extension to include, as either an\n   *     unpacked extension directory or the path to a xpi file.\n   */\n  addExtension(extension) {\n    this.extensions_.push(extension);\n  }\n\n  /**\n   * @return {!Array<string>} A list of extensions to install in this profile.\n   */\n  getExtensions() {\n    return this.extensions_;\n  }\n\n  /**\n   * Sets a desired preference for this profile.\n   * @param {string} key The preference key.\n   * @param {(string|number|boolean)} value The preference value.\n   * @throws {Error} If attempting to set a frozen preference.\n   */\n  setPreference(key, value) {\n    this.preferences_[key] = value;\n  }\n\n  /**\n   * Returns the currently configured value of a profile preference. This does\n   * not include any defaults defined in the profile's template directory user.js\n   * file (if a template were specified on construction).\n   * @param {string} key The desired preference.\n   * @return {(string|number|boolean|undefined)} The current value of the\n   *     requested preference.\n   */\n  getPreference(key) {\n    return this.preferences_[key];\n  }\n\n  /**\n   * @return {!Object} A copy of all currently configured preferences.\n   */\n  getPreferences() {\n    return Object.assign({}, this.preferences_);\n  }\n\n  /**\n   * Specifies which host the driver should listen for commands on. If not\n   * specified, the driver will default to \"localhost\". This option should be\n   * specified when \"localhost\" is not mapped to the loopback address\n   * (127.0.0.1) in `/etc/hosts`.\n   *\n   * @param {string} host the host the driver should listen for commands on\n   */\n  setHost(host) {\n    this.preferences_['webdriver_firefox_allowed_hosts'] = host;\n  }\n\n  /**\n   * @return {boolean} Whether the FirefoxDriver is configured to automatically\n   *     accept untrusted SSL certificates.\n   */\n  acceptUntrustedCerts() {\n    return !!this.preferences_['webdriver_accept_untrusted_certs'];\n  }\n\n  /**\n   * Sets whether the FirefoxDriver should automatically accept untrusted SSL\n   * certificates.\n   * @param {boolean} value .\n   */\n  setAcceptUntrustedCerts(value) {\n    this.preferences_['webdriver_accept_untrusted_certs'] = !!value;\n  }\n\n  /**\n   * Sets whether to assume untrusted certificates come from untrusted issuers.\n   * @param {boolean} value .\n   */\n  setAssumeUntrustedCertIssuer(value) {\n    this.preferences_['webdriver_assume_untrusted_issuer'] = !!value;\n  }\n\n  /**\n   * @return {boolean} Whether to assume untrusted certs come from untrusted\n   *     issuers.\n   */\n  assumeUntrustedCertIssuer() {\n    return !!this.preferences_['webdriver_assume_untrusted_issuer'];\n  }\n\n  /**\n   * Writes this profile to disk.\n   * @return {!Promise<string>} A promise for the path to the new profile\n   *     directory.\n   */\n  writeToDisk() {\n    var profileDir = io.tmpDir();\n    if (this.template_) {\n      profileDir = profileDir.then(function(dir) {\n        return io.copyDir(\n            /** @type {string} */(this.template_),\n            dir, /(parent\\.lock|lock|\\.parentlock)/);\n      }.bind(this));\n    }\n\n    // Freeze preferences for async operations.\n    let prefs = Object.assign({}, this.preferences_);\n\n    // Freeze extensions for async operations.\n    var extensions = this.extensions_.concat();\n\n    return profileDir.then(function(dir) {\n      return writeUserPrefs(prefs, dir);\n    }).then(function(dir) {\n      return installExtensions(extensions, dir);\n    });\n  }\n\n  /**\n   * Write profile to disk, compress its containing directory, and return\n   * it as a Base64 encoded string.\n   *\n   * @return {!Promise<string>} A promise for the encoded profile as\n   *     Base64 string.\n   *\n   */\n  encode() {\n    return this.writeToDisk().then(function(dir) {\n      let zip = new Zip;\n      return zip.addDir(dir)\n          .then(() => zip.toBuffer())\n          .then(buf => buf.toString('base64'));\n    });\n  }\n\n  /**\n   * Encodes this profile as a zipped, base64 encoded directory.\n   * @return {!Promise<string>} A promise for the encoded profile.\n   */\n  [Symbols.serialize]() {\n    return this.encode();\n  }\n}\n\n\n// PUBLIC API\n\n\nexports.Profile = Profile;\nexports.loadUserPrefs = loadUserPrefs;\n"]},"metadata":{},"sourceType":"script"}